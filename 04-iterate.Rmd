# Функциональное программирование

## Зачем писать функции?

Программировать на R --  прежде всего значит писать функции. Несмотря на десятки тысяч функций, обитающих в тысячах пакетов, рано или поздно вам понадобится своя функция, которая будет подходить для решения именно ваших задач. 

Функция и код -- не одно и то же. Чтобы стать функцией, кусок кода должен, как минимум, получить имя. Зачем давать имя коду, который и так работает? 

Вот три причины, которые [приводит](https://r4ds.had.co.nz/functions.html) Хадли Уикхем:

-   у функции есть выразительное имя, которое облегчает понимание кода;
-   при изменении требований необходимо обновлять код только в одном месте, а не во многих;
-   меньше вероятность случайных ошибок при копировании (например, обновление имени переменной в одном месте, но не в другом)

> Writing good functions is a lifetime journey.
>
> --- Hadley Wickham

Чтобы определить функцию, необходимо дать ей имя. Машине все равно, как вы назовете функцию, но тем, кто будет читать код, не все равно. Имена должны быть информативы (поэтому функция `f()` -- плохая идея). Также не стоит переписывать уже существующие в R имена!

Далее следует определить **формальные аргументы** и, при желании, **значения по умолчанию**. Тело функции пишется в фигурных скобках. В конце кода функции располагается команда `return()`; если ее нет, то функция возвращает последнее вычисленное значение (см. [здесь](https://r4ds.had.co.nz/functions.html) о том, когда что предпочесть).

Написание функций -- навык, который можно бесконечно совершенствовать. Начать проще всего с обычного кода. Убедившись, что он работает как надо, вы можете упаковать его в функцию. 

Например, нам нужна функция, которая ищет совпадения в двух векторах и возвращает совпавшие элементы. Сначала решим задачу для двух векторов.

```{r}
x <- c("гнев", "богиня", "воспой")
y <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")
idx <- which(x %in% y) # 2
x[idx]
```

Теперь заменяем фактические переменные на формальные. 

```{r}
common_words <- function(x, y){
  idx <- which(x %in% y)
  x[idx]
}
```

И применяем к новым данным.

```{r}
x <- c("лишь", "явилась", "заря", "розоперстая", "вестница", "утра")
y <- c("вестница", "утра", "заря", "на", "великий", "олимп", "восходила")
common_words(x, y)
```

Ура, все работает! Запомните простое правило: если вы трижды скопировали код, пора писать функцию! 

:::{.task .code}
Загрузите библиотеку `swirl`, выберите курс `R Programming E` и пройдите из него урок 9 `Functions`.
:::

</br>

::::{.ask .question}
Для просмотра исходного кода любой функции необходимо...
::::

```{r echo=FALSE}
checkdown::check_question(
  answer = "набрать имя функции без аргументов и без скобок",
  options = c("набрать имя функции без аргументов и без скобок", "вызвать help к функции", "единственный способ — найти код функции в репозитории на GitHub", "использовать специальную функцию для просмотра кода"),
  right = "Все верно!", 
  wrong = "Не совсем...", 
  type = "radio",
  random_answer_order = TRUE)
```

## Область видимости переменных 

Напишем функцию, которая будет центрировать данные, то есть вычитать среднее из каждого значения (забудем на время, что это уже делает базовая `scale()`):

```{r}
center <- function(x){ 
  n = x - mean(x)
  return(n) 
}

x <- c(5, 10, 15)
center(x) 
```

Внутри нашей функции есть переменная `n`, которую не видно в глобальном окружении. Это **локальная переменная**. Область ее видимости -- тело функции. Когда функция возвращает управление, переменная исчезает. Обратное неверно: глобальные переменные доступны в теле функции.

## Аргументы функции

Функция может принимать произвольное число аргументов. Доработаем наш код:

```{r}
center <- function(x, na.rm = F){
  if(na.rm) { x <- x[!is.na(x)]} # добавим условие
  x - mean(x) # на этот раз без return()
}

x <- c(5, 10, NA)
center(x)
```

Что произошло? Почему следующий код выдает другой результат?

```{r}
center(x, na.rm = T)
```

Вычисления в R **ленивы**, то есть они откладываются до тех пор, пока не понадобится результат. Если вы зададите аргумент, который не нужен в теле функции, ошибки не будет.

```{r}
center <- function(x, na.rm = F, what_is_your_name){
  if(na.rm) { x <- x[!is.na(x)]} # добавим условие
  x - mean(x) # на этот раз без return()
}

center(x, na.rm = T)
center(x, na.rm = T, what_is_your_name = "Locusclassicus")
```

Часто имеет смысл добавить условие остановки или сообщение, которое будет распечатано в консоль при выполнении.

```{r eval=FALSE}
center <- function(x){
  if (length(x) == 1) {stop("И без меня посчитаете")}
  x - mean(x) # на этот раз без return()
}

x <- 10
center(x) # вернет ошибку
```

## Векторизируй это

Теперь самое главное: если мы хотим применить функцию к каждому элементу вектора, то в большинстве случаев достаточно просто вызвать функцию. Это называется **векторизация**. 

Это относится не только ко многим встроенным функциям R, но и к даже к операторам. `x + 4` в действительности представляет собой `+(x, 4)`:

```{r}
x <- c(1.2, 2.51, 3.8)

`+`(x, 4) 
```

Ключевую роль здесь играет переработка данных, о которой мы уже говорили: короткий вектор повторяется до тех пор, пока его длина не сравняется с длиной более длинного вектора. Как-то так:

$$\left(
    \begin{array}{c}
      1.2 \\
      2.51 \\
      3.8
    \end{array}
  \right) + \left(
    \begin{array}{c}
      4 \\
      4 \\
      4
    \end{array}
  \right)$$


Понимание того, как действуют векторизованные вычисления, очень важно для написания корректного кода. Посмотрите на пример ниже: почему функция `is_article()` возвращает два значения, хотя на входе только одно?

```{r}
is_article <- function(x){
  x == c("a", "the")
}

x <- "the"
is_article(x)
```

Поскольку векторы сравниваются поэлементно, то функция ниже вернет разный результат в зависимости от того, в каком порядке заданы элементы: 

```{r}
x <- c("just", "the")
is_article(x) 

x <- c("the", "just")
is_article(x) # взрыв мозга
```

Подумайте, вектор какого типа и какой длины вернет код ниже. 

```{r}
is_article <- function(x) { 
  articles <- c("a", "the")
  x %in% articles
}

x <- c(rep("the", 5), rep("if", 5))
# is_article(x)
```

:::{.task .code}
Напишите функцию `awesome_plot`, которая будет принимать в качестве аргументов два вектора, трансформировать их в тиббл и строить  диаграмму рассеяния при помощи ggplot(). Задайте цвет и прозрачность точек, а в подзаголовке выведите коеффицент корреляции.
:::

</br>

## Векторизованные конструкции

### Циклы

Еще один способ повторить действия в R, при этом не копируя один и тот же код много раз, -- это циклы.

> Один из главных принципов программирования на R гласит, что следует обходиться без циклов, а если это невозможно, то циклы должны быть простыми.
>
> --- Нормат Мэтлофф

Существует два основных цикла: цикл `for` и цикл `while`. На практике чаще используется цикл `for`, потому что цикл `while` легко отправить в бесконечность.

#### Цикл `for`

Цикл ниже считает количество букв для каждого слова в векторе.

```{r}
y <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")

result <- c()
for(i in y) { 
  n <- nchar(i)
  result <- c(result, n)
}

result
```

В данном случае мы указали, что надо совершить какую-то операцию над каждым элементом вектора; но по сути это избыточно, потому что `nchar()` тоже векторизована.

```{r}
nchar(y)
```
Поэтому чаще цикл `for` применяют к другим структурам данных. Например, к спискам и датафреймам. Загрузим и немного изменим датасет о гапаксах у Платона. Изменения нужны, так как цикл работает для данных только одного типа, в то время как в нашей таблице столбец `dialogue` содержит символьные строки, а `group` -- фактор. Обратите внимание, что оператор `pipe` и функции из `dplyr` работают и с обычными датафреймами:

```{r echo=FALSE, message=F}
library(tidyverse)
load("./data/HapaxPlato.Rdata")
```

```{r}
rownames(hapax_plato) <- hapax_plato$dialogue 

hapax_plato <- hapax_plato %>% select(-group, -dialogue) # 
str(hapax_plato)
```

Сейчас все данные в нашей таблице имеют тип `chr`, то есть строка, и при помощи цикла мы можем их трансформировать.

```{r}
for (i in seq_along(hapax_plato)) {  # seq_along ≈ 1:length(x)
  hapax_plato[,i] <- as.numeric(hapax_plato[,i])
}

str(hapax_plato) # убеждаемся, что все получилось
```

При помощи циклов можно не только трансформировать данные, но и создавать новые. Чтобы посчитать среднее для столбца, цикл писать не надо: для этого есть функция `colSums()` (или, для других задач, `rowSums()`). А вот посчитать медиану таким образом не получится, тут может пригодиться цикл.

```{r}
library(tictoc)

tic()
medians <- c()
for (i in seq_along(hapax_plato)) { 
  m <- median(hapax_plato[,i])
  medians <- c(medians, m)
}
toc()

medians
```

Мы сохранили результат, инициировав пустой вектор, к которому затем привязали данные по каждому столбцу. Это не всегда хорошая идея, поскольку для больших данных может сильно замедлить цикл[^04-iterate-3]. Еще один способ -- сразу инициировать вектор нужной длины. Сравнить скорость можно при помощи пакета `tictoc`.

[^04-iterate-3]: <https://r4ds.had.co.nz/iteration.html>

```{r}
tic()
medians <- vector("double", ncol(hapax_plato))
for (i in seq_along(hapax_plato)) { 
  medians[i] <- median(hapax_plato[,i])
}
toc()
```

Второй способ чуть быстрее, и для больших данных это может быть существенно (знала бы я это раньше).

:::infobox
Вы уже заметили, что в циклах часто используется буква `i`. Но никакой особой магии в ней нет! 
:::

</br>


#### Цикл `while`

Как уже говорилось, с циклами `while` стоит быть осторожнее. Посмотрите, например, на этот цикл, который перебирает слова, пока не найдет слово длиной 6 букв. Что могло пойти не так?

```{r}
tic()
k <- 0
n <- 0
while (n != 6) {
  k <- k + 1
  n <- nchar(y[k])
}
y[k]
toc()
```

То же самое можно сделать без цикла, причем быстрее!

```{r}
tic()
y[nchar(y) == 6][1] 
toc()
```

В целом, ничего незаконного в циклах нет, но

- множество вложенных друг в друга циклов сложно воспринимать;
- порой они могут замедлить выполнение кода. 

И в базовом R, и в диалекте tidyverse для этого есть несколько решений, о которых скажем чуть ниже. Сначала рассмотрим еще одну векторизованную конструкцию -- условие. 

:::{.task .code}
Напишите цикл, который для каждого столбца в таблице считает число отсутствующих значений и выводит это число вместе с названием столбца. Возспользуйтесь датасетом `starwars` из пакета `dplyr`.
:::

</br>

### Условия

Иногда необходимо ограничить выполнение функции неким условием. Короткие условия можно писать в одну строку без фигурных скобок.

```{r}
if(any(nchar(y) > 6)) print("многабукв")
```

Более сложные и множественные условия требуют фигурных скобок. Можно сравнить это с условным периодом: протасис (всегда либо TRUE, либо FALSE) в круглых скобках, аподосис в фигурных.

```{r}
if (sum(nchar(y)) > 10) {
  print("много букв")
} else if (sum(nchar(y)) < 5) {
  print("мало букв")
} else {
  print("норм букв")
}
```

Также в R можно использовать специальную функцию:

```{r}
ifelse((sum(nchar(y)) > 10), "много букв", "мало букв")
```

Прописывая условие, не забывайте, что применение булева оператора к вектору возвращает логический вектор:

```{r} 
x <- c(1:10)
x >= 5
```

Такое условие вернет ошибку.

```{r error=TRUE}
if (x >= 5) print("все сломалось")
```

Можно скорректировать код так:

```{r}
if (any(x >= 5)) print("все сработало")
```

По той же причине внутри условия не надо использовать логические операторы `|` ("или") или `&` ("и"), потому что они векторизованы:

```{r}
x < 3 | x > 7
```

:::{.task .code}
Доработайте код из задания выше. Теперь цикл должен считать число отсутствующих значений и выводить название только тех столбцов, где число `NA` больше 5.
:::

Сколько таких столбцов в датасете `starwars`?

```{r echo=FALSE}
check_question(answer=4, right="С вами явно пребывает сила", wrong = "Можешь многое узнать ты еще")
```

## Вместо циклов: базовый R и tidyverse

Функция **`tapply()`** из базового R принимает на входе вектор, фактор (или список факторов) и функцию. Каждый фактор должен быть той же длины, что и вектор. Код ниже считает средний процент гапаксов по группам диалогов:

```{r}
load("./data/HapaxPlato.Rdata")
```

```{r}
# подготавливаем векторы 
my_fct <- as.factor(hapax_plato$group)
my_vct <- as.numeric(hapax_plato$ratio)

# применяем к ним функцию mean()
tapply(my_vct, my_fct, mean)
```

На диалекте tidyverse эта задача решается так:

```{r}
hapax_plato %>% 
  mutate(ratio = as.numeric(ratio)) %>% 
  group_by(group) %>% 
  summarise(mean = mean(ratio))
```

Функция **`apply()`** вызывает функцию для каждой строки или столбца матрицы или датафрейма.

```{r}
# избавляемся от факторов и строк
rownames(hapax_plato) <- hapax_plato$dialogue
hapax_plato <- subset(hapax_plato, select = -c(dialogue, group)) 

# преобразуем столбцы в числовой формат при помощи apply
tic()
hapax_plato<- apply(hapax_plato, 2, as.numeric)
toc()
```

Сравните со скростью цикла, который мы написали выше:
```{r}
load("./data/HapaxPlato.Rdata")
# избавляемся от факторов и строк
rownames(hapax_plato) <- hapax_plato$dialogue
hapax_plato <- subset(hapax_plato, select = -c(dialogue, group)) 
```

```{r}
tic()
for (i in seq_along(hapax_plato)) {  
  hapax_plato[,i] <- as.numeric(hapax_plato[,i])
}
toc()
```
Функция `apply()` позволяет применять к данным собственные функции, в том числе анонимные.

```{r}
hapax_centered <- apply(hapax_plato, 2, function(x) x - mean(x))
head(hapax_centered)
```

Опять-таки, все это решается (даже проще) в грамматике dplyr:

```{r eval=F}
as_tibble(hapax_plato) %>% 
  mutate(words = words - mean(words), 
         hapax = hapax - mean(hapax),
         ratio = ratio - mean(ratio))
```

Видно, что по времени мы при этом сильно не выигрываем; к тому же, нам пришлось повторить один код три раза. Значит, надо что-то менять. Например, так[^04-iterate-4]:

[^04-iterate-4]: <https://dplyr.tidyverse.org/reference/mutate_all.html>

```{r eval=F}
tic()
as_tibble(hapax_plato) %>% 
  mutate_all(function(x) x - mean(x))
toc()
```

Или даже так[^04-iterate-5]:

[^04-iterate-5]: <https://dplyr.tidyverse.org/articles/colwise.html>

```{r}
fn <- function(x) x - mean(x)
as_tibble(hapax_plato) %>%
  mutate(across(1:3, fn)) %>% invisible()
```

В любом случае, нам удалось обойтись без цикла, код понятен и хорошо читается. 

Функции **`lapply()`** и **`sapply()`** подходят для применения функций к спискам (и к датафреймам, которые по сути представляют собой прямоугольные списки).

Чтобы понять, как они работают, сначала создадим список.

:::infobox
При анализе текста со списками приходится иметь дело достаточно часто: объекты типа `stylo.corpus`, которые создает пакет [`stylo`](https://rdrr.io/cran/stylo), по сути являются списками.
:::

Создадим игрушечный корпус из двух игрушечных текстов.

```{r}
x <- c("гнев", "богиня", "воспой")
y <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")
corpus <- list(x = x, y = y)
```

Наш условный корпус -- это список из 2 элементов (текстов), а каждый текст хранится как символьный вектор. Допустим, мы хотим взять из каждого диалога выборку размером 5 слов, то есть применить функцию `sample()` к элементам списка. При помощи `lapply()` (l = list) это делается так:

```{r}
set.seed(0211) 
lapply(corpus, sample, 5, replace = T)
```

Функция **`sapply()`** ведет себя так же, но упрощает результат до вектора или матрицы (s = simplify).

```{r}
sapply(corpus, sample, 5, replace = T)
```
Функция **`vapply()`** позволяет задать тип данных на выходе.

```{r}
vapply(corpus, sample, size = 5, replace = T, character(5))
```

Поскольку наш "корпус" -- это список, то применить грамматику `dplyr` не очень удобно, но списко легко превращается в таблицу:

```{r}
stack(corpus) # передвинуть и переименовать: `relocate()` и `rename()`
```

Теперь повторные выборки можно делать так:

```{r}
set.seed(0211)
stack(corpus) %>% 
  group_by(ind) %>% 
  sample_n(size = 5, replace = T)
```

:::{.task .code}
Пройдите урок 10 `lapply and sapply` и урок 11 `vapply and tapply` из курса `R Programming E` в `swirl`.
:::

</br>

## Purrr

По-настоящему мощный инструмент для итераций -- это пакет `purrr` из семейства `tidyverse`^[https://purrr.tidyverse.org/]. Разработчики предупреждают, что потребуется время, чтобы овладеть этим инструментом [@wickham2016].

> You should never feel bad about using a loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work.
> 
> --- Hadley Wickham & Garrett Grolemund

В семействе функций `map_` из этого пакета всего 23 вариации^[https://adv-r.hadley.nz/functionals.html]. Вот основные из них:

- `map()`
- `map_lgl()`
- `map_int()`
- `map_dbl()`
- `map_chr()`

Все они принимают на входе данные и функцию, которую следует к ним применить, и возвращают результат в том виде, который указан после подчеркивания. Просто `map()` вернет список, а `map_df()` -- таблицу:

```{r}
hapax_plato  %>%
  as_tibble() %>%
  map_df(center) %>% 
  head()
```

Если на выходе требуется числовой вектор, то используем суффикс `dbl`:

```{r}
round(map_dbl(hapax_plato, mean), 3) # это именованный вектор!
```

Если необходимо несколько раз вызывать одну и ту же функцию с двумя аргументами, используется функция `map2()` ^[https://adv-r.hadley.nz/functionals.html]. Аргументы, которые меняются при каждом вызове, пишутся до функции; аргументы, которые остаются неизменны, -- после.


```{r}
mean = list(5, 10, -3)
sd = list(1, 5, 50)
map2(mean, sd, rnorm, n = 5)
```

![Как работает `map2()`](https://d33wubrfki0l68.cloudfront.net/68a21c4a103426c3b311c9dcfad8fe379d4892f1/55c9d/diagrams/lists-map2.png){ width=60% }

Это можно обобщить следующим образом ([источник](https://adv-r.hadley.nz/functionals.html#map2)){ width=60% }:

![](https://d33wubrfki0l68.cloudfront.net/7a545699ff7069a98329fcfbe6e42b734507eb16/211a5/diagrams/functionals/map2-arg.png)

Можно было бы предположить, что должны быть и map3(), map4() и т.д., но во всех случаеях, когда у функции больше двух аргументов,  используется `pmap()`.

## Пример итерации

Функция `map2()` в анализе текста: функция, которая принимает на входе список таблиц, созданных функцией `slide`, и назначает каждому окну id.^[Пример отсюда, с некоторыми упрощениями: https://smltar.com/embeddings.html#understand-word-embeddings-by-finding-them-yourself. Подробный разбор в [видео](https://vk.com/video-211800158_456239215)]. Используется для создания скользящего окна при создании эмбеддингов.

```{r}
corpus_tbl <- as_tibble(stack(corpus))
windows <- slider::slide(corpus_tbl, ~.x, .after = 1)
out <- map2(.x = windows, .y = 1:length(windows), ~ mutate(.x, window_id = .y)) # out is a list
out[2]
```

Поскольку второй аргумент -- это, по сути, индекс, можно было бы использовать функцию `imap()`:

```{r}
out <- imap(.x = windows, ~ mutate(.x, window_id = .y))
out[2:3]
```

## Furrr

Про параллельные вычисления, если останутся силы.
