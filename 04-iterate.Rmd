# Функциональное программирование

## Написание функций

Суть программирования на R сводится к написанию функций. Функция представляет собой набор команд, которые получают входные данные, используют их для вычисления других значений и возвращают результат [@мэтлофф2019].

Чтобы определить функцию, необходимо дать ей имя, определить **формальные аргументы** и, при желании, **значения по умолчанию**. Тело функции пишется в фигурных скобках. В конце кода функции располагается команда `return()`; если ее нет, то функция возвращает последнее вычисленное значение (см. [здесь](https://r4ds.had.co.nz/functions.html) о том, когда что предпочесть).

Напишем функцию, которая будет центрировать данные, то есть вычитать среднее из каждого значения:

```{r}
center <- function(x){ 
  n = x - mean(x)
  return(n)
}

x <- c(5, 10, 15)
center(x) # это уже не формальный, а фактический аргумент
```

:::infobox
То же  делает встроенная функция `scale()` (если значение аргумента `scale = F`; в противном случае разность дополнительно делится на стандартное отклонение, это называется стандартизация).
:::

Внутри нашей функции есть переменная `n`, которую не видно в глобальном окружении. Это **локальная переменная**. Область ее видимости -- тело функции. Когда функция возвращает управление, переменная исчезает. Обратное неверно: глобальные переменные доступны в теле функции.

Функция может принимать произвольное число аргументов. Доработаем наш код:

```{r}
center <- function(x, na.rm = F){
  if(na.rm) { x <- x[!is.na(x)]} # добавим условие
  x - mean(x) # на этот раз без return()
}

x <- c(5, 10, NA)
center(x)
```

Что произошло? Почему следующий код выдает другой результат?

```{r}
center(x, na.rm = T)
```

Вычисления в R **ленивы**, то есть они откладываются до тех пор, пока не понадобится результат. Если вы зададите аргумент, который не нужен в теле функции, ошибки не будет.

```{r}
center <- function(x, na.rm = F, what_is_your_name){
  if(na.rm) { x <- x[!is.na(x)]} # добавим условие
  x - mean(x) # на этот раз без return()
}

center(x, na.rm = T)
center(x, na.rm = T, what_is_your_name = "Locusclassicus")
```

Машине все равно, как вы назовете функцию, но тем, кто будет читать код, не все равно. Имена должны быть информативы (поэтому функция `f()` -- плохая идея). Также не стоит переписывать уже существующие в R имена!

Часто имеет смысл добавить условие остановки или сообщение, которое будет распечатано в консоль при выполнении.

```{r eval=FALSE}
center <- function(x){
  if (length(x) == 1) {stop("И без меня посчитает")}
  x - mean(x) # на этот раз без return()
}

x <- 10
center(x) # вернет ошибку
```

Впрочем, в таких простых функциях в R нет необходимости. Сравните:

```{r}
x <- c(5, 10, 15)
x - mean(x)
```

## Векторизируй это

Если имеется функция `f()`, которая должна быть применена ко всем элементам вектора `x`, то во многих случаях задача решается простым вызовом `f()` для самого вектора `x`. Это и есть векторизация. Она упрощает код и улучшает быстродействие.

::: infobox
Если функция R использует векторизованные операции, то она тоже является векторизованной [@мэтлофф2019].
:::

Это относится не только ко многим встроенным функциям R, но и к даже к операторам. `x + 4` в действительности представляет собой `+(x, 4)`:

```{r}
x <- c(1.2, 2.51, 3.8)

# пример со встроенной функцией
round(x)

# пример с оператором
`+`(x, 4) 
```

Ключевую роль здесь играет переработка данных, о которой мы уже говорили: короткий вектор повторяется до тех пор, пока его длина не сравняется с длиной более длинного вектора.

```{r}
is_article <- function(x){
  x == c("a", "the")
}

x <- "the"
is_article(x) # возвращает два значения, хотя на входе было одно
```

В двух примерах ниже векторы равной длины, но тут тоже есть особенность.

```{r}
x <- c("just", "the")
is_article(x) 

x <- c("the", "just")
is_article(x) # взрыв мозга
```

Почему так?

::: spoiler
Внутри нашей функции вектор, а два вектора сравниваются поэлементно!
:::

Получается, что для сравнения списка слов со списком артиклей нам надо переписать функцию. Например, так:

```{r}
is_article <- function(x) { 
  articles <- c("a", "the")
  x %in% articles
}

x <- c(rep("the", 5), rep("if", 5))
is_article(x)

sum(is_article(x)) 
```

## Зачем писать функции?

Функции имеют три преимущества перед простой копипастой:

-   у функции есть выразительное имя, которое облегчает понимание кода;
-   при изменении требований необходимо обновлять код только в одном месте, а не во многих;
-   меньше вероятность случайных ошибок при копировании (например, обновление имени переменной в одном месте, но не в другом)[подробнее](https://r4ds.had.co.nz/functions.html)

::: infobox
Запомните простое правило: если вы трижды скопировали код, пора писать функцию!
:::


> Writing good functions is a lifetime journey.
>
> --- Hadley Wickham

Это не так сложно. Сначала пишем обычный код, потом превращаем его в функцию. Например, нам нужна функция, которая ищет совпадения в двух векторах и возвращает совпавшие элементы.

```{r}
# сначала решаем задачу для двух векторов
x <- c("гнев", "богиня", "воспой")
y <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")
idx <- which(x %in% y)
x[idx]

# потом упаковываем в функцию
common_words <- function(x, y){
  idx <- which(x %in% y)
  x[idx]
}

# применяем к новым данным
x <- c("лишь", "явилась", "заря", "розоперстая", "вестница", "утра")
y <- c("вестница", "утра", "заря", "на", "великий", "олимп", "восходила")
common_words(x, y)
```

И ура, все работает!

Кроме того, очень полезно читать чужой код (если он хорошо написан). Начинку функции можно распечатать в консоль, если ввести ее название без скобок. Ниже код функции из пакета `Stylo`; эта функция отвечает за вычисление знаменитой Delta Берроуза. Попробуйте понять, что она делает.

```{r message = F}
library(stylo)
dist.delta
```

## Векторизованные конструкции

### Циклы

Еще один способ повторить действия в R, при этом не копируя один и тот же код много раз, -- это циклы.

> Один из главных принципов программирования на R гласит, что следует обходиться без циклов, а если это невозможно, то циклы должны быть простыми.
>
> --- Нормат Мэтлофф

Существует два основных цикла: цикл `for` и цикл `while`. На практике чаще используется цикл `for`, потому что цикл `while` легко отправить в бесконечность.

#### Цикл `for`

Цикл ниже считает количество букв для каждого слова в векторе.

```{r}
y <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")

result <- c()
for(i in y) { 
  n <- nchar(i)
  result <- c(result, n)
}

result
```

В данном случае мы указали, что надо совершить какую-то операцию над каждым элементом вектора; но по сути это избыточно, потому что `nchar()` тоже векторизована.

```{r}
nchar(y)
```

Поэтому чаще цикл `for` применяют к другим структурам данных. Например, к спискам и датафреймам (хотя и этого можно избежать, о чем будет сказано дальше). Загрузим и немного изменим датасет о гапаксах у Платона. Изменения нужны, так как цикл работает для данных только одного вида.

```{r echo=FALSE}
library(tidyverse)
load("./datasets/HapaxPlato.Rdata")
```

```{r}
rownames(hapax_plato) <- hapax_plato$dialogue
hapax_plato <- hapax_plato %>% select(-ratio, -group, -dialogue) # оператор pipe и функции из dplyr работают и с обычными датафреймами!
str(hapax_plato)
```

Сейчас данные в нашей таблице имеют тип `chr`, то есть строка, и при помощи цикла мы можем их трансформировать.

```{r}
for (i in seq_along(hapax_plato)) {  # seq_along ≈ 1:length(x)
  hapax_plato[,i] <- as.numeric(hapax_plato[,i])
}

str(hapax_plato) # убеждаемся, что все получилось
```

При помощи циклов можно не только трансформировать данные, но и создавать новые. Чтобы посчитать среднее для столбца, цикл писать не надо: для этого есть функция `colSums()` (или, для других задач, `rowSums()`). А вот посчитать медиану таким образом не получится, тут может пригодиться цикл.

```{r}
medians <- c()
for (i in seq_along(hapax_plato)) { 
  m <- median(hapax_plato[,i])
  medians <- c(medians, m)
}

medians
```

Мы сохранили результат, инициировав пустой вектор, к которому затем привязали данные по каждому столбцу. Это не всегда хорошая идея, поскольку для больших данных может сильно замедлить цикл[^04-iterate-3]. Еще один способ -- сразу инициировать вектор нужной длины.

[^04-iterate-3]: <https://r4ds.had.co.nz/iteration.html>

```{r}
medians <- vector("double", ncol(hapax_plato))
for (i in seq_along(hapax_plato)) { 
  medians[i] <- median(hapax_plato[,i])
}

medians
```

Сравнить скорость можно при помощи пакета `tictoc`.

```{r}
library(tictoc)

# способ первый 
tic()
medians <- c()
for (i in seq_along(hapax_plato)) { 
  m <- median(hapax_plato[,i])
  medians <- c(medians, m)
}
toc()

# способ второй
tic()
medians <- vector("double", ncol(hapax_plato))
for (i in seq_along(hapax_plato)) { 
  medians[i] <- median(hapax_plato[,i])
}
toc()
```

Второй способ чуть быстрее, и для больших данных это может быть существенно (знала бы я это раньше).

Вы уже заметили, что в циклах часто используется буква `i`. Но никакой особой магии в ней нет!

#### Цикл `while`

Как уже говорилось, с циклами `while` стоит быть осторожнее. Посмотрите, например, на этот цикл, который перебирает слова, пока не найдет слово длиной 6 букв. Что могло пойти не так?

```{r}
k <- 0
n <- 0
while (n != 6) {
  k <- k + 1
  n <- nchar(y[k])
}

y[k]
```

То же самое можно сделать без цикла. Если подходящего значения не найдется, нам вернется `NA`.

```{r}
y[nchar(y) == 6][1] 
```

### Условия

Задействуются в тех случаях, когда выполнение функции ограничивается неким условием.

```{r}
if(any(nchar(y) > 6)) print("многабукв")
```

Внутри условия не надо использовать логические операторы `|` ("или") или `&` ("и"), потому что они векторизованы:

```{r}
y
nchar(y) > 6 | nchar(y) < 2
```

Вместо этого можно применять `||` ("или") или `&&` ("и"), которые остановятся, дойдя до первого истинного значения.

```{r}
nchar(y) > 6 || nchar(y) < 2 
```

Множественные условия задаются так:

```{r}
if (sum(nchar(y)) > 10) {
  print("много букв")
} else if (sum(nchar(y)) < 5) {
  print("мало букв")
} else {
  print("норм букв")
}
```

Но можно и короче:

```{r}
ifelse((sum(nchar(y)) > 10), "много букв", "мало букв")
```

## Семейство функций \_apply из базового R

Как уже было сказано, лучше обойтись без циклов, для этого в базовом R есть семейство функций \_apply.

### tapply()

Принимает на входе вектор, фактор (или список факторов) и функцию. Каждый фактор должен быть той же длины, что и вектор.

```{r}
load("./datasets/HapaxPlato.Rdata")
```

```{r}
my_fct <- as.factor(hapax_plato$group)
my_vct <- as.numeric(hapax_plato$ratio)
tapply(my_vct, my_fct, mean)
```

На диалекте tidyverse эта задача решается так:

```{r}
hapax_plato %>% 
  mutate(ratio = as.numeric(ratio)) %>% 
  group_by(group) %>% 
  summarise(mean = mean(ratio))
```

### apply()

Вызывает функцию для каждой строки или столбца матрицы или датафрейма.

```{r}
# переносим названия диалогов в названия рядов
rownames(hapax_plato) <- hapax_plato$dialogue
hapax_plato <- subset(hapax_plato, select = -c(dialogue, group)) # еще один способ убрать столбцы

# уточним вид данных по столбцам
str(hapax_plato)

# преобразуем столбцы в числовой формат
hapax_plato<- apply(hapax_plato, 2, as.numeric)

# и посчитаем стандартное отклонение по столбцам
round((apply(hapax_plato, 2, sd)), 3)
```

В данном случае мы передали `apply(`) функцию `sd()` из основного пакета `stats`, но можно написать свою (в том числе анонимную).

```{r}
hapax_centered <- apply(hapax_plato, 2, function(x) x - mean(x))
head(hapax_centered)
```

Опять-таки, все это решается (даже проще) в грамматике dplyr:

```{r eval=F}
as_tibble(hapax_plato) %>% 
  mutate(words = words - mean(words), 
         hapax = hapax - mean(hapax),
         ratio = ratio - mean(ratio))
```

Но мы повторили один код три раза! Значит, это надо упростить! Например, так[^04-iterate-4]:

[^04-iterate-4]: <https://dplyr.tidyverse.org/reference/mutate_all.html>

```{r eval=F}
as_tibble(hapax_plato) %>% 
  mutate_all(function(x) x - mean(x))
```

Или даже так[^04-iterate-5]:

[^04-iterate-5]: <https://dplyr.tidyverse.org/articles/colwise.html>

```{r eval=F}
fn <- function(x) x - mean(x)
as_tibble(hapax_plato) %>%
  mutate(across(1:3, fn))
```

В любом случае, нам удалось обойтись без цикла, код понятен и хорошо читается.

### lapply() и sapply()

Функции `lapply()` и `sapply()` подходят для применения функций к спискам. Чтобы понять, как они работают, сначала загрузим список.

Списки, с которыми при анализе текста приходится иметь дело достаточно часто, -- это объекты типа `stylo.corpus`, которые создает пакет `stylo`[^04-iterate-6].

[^04-iterate-6]: <https://rdrr.io/cran/stylo/>

Загрузим корпус диалогов Платона.

```{r echo=F}
# library(stylo)
# corpus <- load.corpus.and.parse(corpus.dir = "corpora/plato")
# save(corpus, file = "datasets/PlatoStylo.Rdata")
```

```{r}
load("./datasets/PlatoStylo.Rdata")
class(corpus)
```

Если вы работаете в RStudio, то, нажав на объект `corpus` в окружении, вы увидите нечто такое (конечно, детали зависят от того, какие тексты у вас лежат в указанной директории):

**Добавить картинку Превью корпуса** 

Здесь хорошо видно, что весь корпус -- это список из 26 элементов (диалогов), а каждый диалог -- символьный вектор. Проверим, используя индексирование списка, о котором шла речь выше:

```{r}
class(corpus[[1]])
```
Допустим, мы хотим взять из каждого диалога выборку размером 1000 слов, то есть применить функцию `sample()` к элементам списка. При помощи `lapply()` (l = list) это делается так:

```{r}
samples <- lapply(corpus, sample, 1000, replace = T)
```

Объект samples тоже представляет собой список, но теперь для всех диалогов одна длина вектора.

Функция `sapply()` ведет себя так же, но упрощает результат до вектора или матрицы (s = simplify).

```{r}
s_sample <- sapply(corpus[1:2], sample, 5, replace = F)
s_sample
```
Поскольку это список, то применить грамматику `dplyr` не очень удобно, но корпус stylo легко превращается в тиббл:

```{r}
corpus_df <- stack(corpus)
head(corpus_df)
```

Приведем в порядок:

```{r}
corpus_tbl <- corpus_df %>% 
  as_tibble() %>% 
  relocate(ind, .before = values) %>% 
  rename(title = ind, 
         word = values)

corpus_tbl
```

Теперь повторные выборки можно делать так:

```{r}
samples <- corpus_tbl %>% 
  group_by(title) %>% 
  sample_n(size = 1000, replace = T)

dim(samples) # видно, что на каждый диалог приходится ровно 1000 слов
```

И мы снова обошлись без цикла!

## Purrr

Настоящая мощь итерации -- это пакет `purrr` из семейства `tidyverse`^[https://purrr.tidyverse.org/]. Но это с непривычки может быть непросто.

> You should never feel bad about using a loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work.
> 
> --- Hadley Wickham & Garrett Grolemund

Основная функция этого пакета -- `map()` -- имеет 23 вариации^[https://adv-r.hadley.nz/functionals.html]. Главное достоинство `map` -- не скорость, а ясность: код проще писать и читать [@wickham2016]. 

Основные функции: 

- `map(.x, .f, ..., .progress = FALSE)`
- `map_lgl(.x, .f, ..., .progress = FALSE)`
- `map_int(.x, .f, ..., .progress = FALSE)`
- `map_dbl(.x, .f, ..., .progress = FALSE)`
- `map_chr(.x, .f, ..., .progress = FALSE)`

Другие:

- `map_if()`
- `imap()`
- `lmap()`
- `map2()`
- `map_if()`
- `modify()`

и др. Итерации в purrr -- очень большая тема^[См., например: https://www.emilhvitfeldt.com/post/2018-01-08-purrr-tips-and-tricks/], и здесь рассмотрим только некоторые примеры.

### map_df() и map_dbl()

Получив на входе тиббл, map применяет заданную функцию к каждому столбцу.

```{r}
hapax_plato <- as_tibble(hapax_plato)
map_df(hapax_plato, center) 
```

Функции map -- pipeable, поэтому можно записать это так:

```{r eval=FALSE}
hapax_plato %>% map_df(center)
```

Формат выводимых данных предсказуем. Например, если на выходе требуется числовой вектор, то используем суффикс `dbl`:

```{r}
round(map_dbl(hapax_plato, mean), 3)
```

### map2()

`map2()` принимает на входе сразу два вектора и подходит в тех случаях, когда необходимо несколько раз вызывать одну и ту же функцию с двумя аргументами^[https://adv-r.hadley.nz/functionals.html].


```{r}
mean = list(1, 10, 100)
sd = list(0.5, 5, 50)
map2(mean, sd, rnorm, n = 3)
```


:::infobox
Аргументы, которые меняются при каждом вызове, пишутся до функции; аргументы, которые остаются неизменны, -- после.
:::

**Добавить картинку про мэп2**

Если у функции больше двух аргументов, то используется `pnorm()`.

Пример применения функции `map2()` в анализе текста: создание скользящего окна^[https://smltar.com/embeddings.html#understand-word-embeddings-by-finding-them-yourself]. Подробный разбор в [видео](https://vk.com/video-211800158_456239215)

```{r}
library(slider)
windows <- slide(corpus_tbl[1:36,], ~.x, .after = 6)
out <- map2(.x = windows, .y = 1:length(windows), ~ mutate(.x, window_id = .y)) # out is a list
out[2]
```

## Furrr

Про параллельные вычисления, если останутся силы.
