# Визуализации

## Базовый R

В R существуют три основные системы построения графиков, которые могут быть полезны для достижения разных целей. Базовый R -- это самая старая система, и в ее основе лежит идея палитры художника[^02-plot-1].

[^02-plot-1]: <https://youtu.be/a4mvbyNGdBA>

Идея заключается в том, что у вас есть чистый холст, на который вы добавляете что-то одно за другим: например, сначала вы создаете **диаграмму рассеяния** с несколькими точками, затем вы добавляете метки, линию регрессии, заголовки и т.п. Каждая деталь графика занимает еще одну строчку кода.

Это интуитивно понятная модель, потому что часто в самом начале, исследуя данные, мы часто не знаем, какой график мы хотим построить. Обычно мы начинаем это построение с функции `plot()`, а затем добавляем функции, которые аннотируют график. Вот простой пример на данных о гапаксах у Платона, которые мы видели раньше.

Чтобы построить диаграмму рассеяния (scatter plot), нужно передать функции `plot()` в качестве аргументов названия тех столбцов, которые мы хотим изобразить по осям x и y. Это можно записать так: `plot(x, y)`. Или так: `plot(y ~ x)`. Знак `~` (тильда) указывает на функцию.

```{r echo=F}
load(file = "data/HapaxPlato.Rdata")
hapax_plato$group <- as.factor(hapax_plato$group)
hapax_plato[,2:4] <- sapply(hapax_plato[,2:4],as.numeric)
```

```{r message=FALSE}
attach(hapax_plato)
plot(hapax ~ words)
```

Это можно записать и иначе: `plot(hapax_plato$hapax ~ hapax_plato$words)`. Результат будет одинаковый.

Теперь беремся за палитру. Данные скучились в левом нижнем углу и потому плохо читаются. Мы можем пожертвовать двумя очень длинными диалогами (это "Государство" и "Законы") и сделать zoom in, указав вручную границы осей.

```{r message=FALSE}
attach(hapax_plato)
plot(hapax ~ words, xlim = c(0, 30000), ylim = c(0, 500))  
```

Но так мы все-таки теряем какую-то информацию -- а вдруг она важная? Еще один способ справиться со слипшимися данными -- преобразовать их. Применим логарифмическое преобразование. Обратите внимание, как меняются значения на осях.

```{r message=FALSE}
attach(hapax_plato)
options(scipen=999) # избавляет от научной нотации
plot(words, hapax, log = "xy")  
# добавим текст
text(hapax ~ words, labels = dialogue, pos = 2, cex = 0.7)
```

Уже гораздо интереснее! Попробуем обозначить цветом и формой пересказанные и прямые диалоги. Форма задается внутри функции `plot()` при помощи атрибута `pch`. Числовые значения этого атрибута соответствуют следующим значкам. Мы используем 2, 3 и 5.

![Значения атрибута pch](https://d33wubrfki0l68.cloudfront.net/cc94c11128cb951a9fd833667d7c8e726cde8448/b3728/visualize_files/figure-html/shapes-1.png)

Перестраиваем наш график.

```{r message=FALSE}
attach(hapax_plato)
options(scipen=999) # избавляет от научной нотации
plot(words, hapax, log = "xy", col = c("darkblue", "darkgreen", "darkred")[group], 
     pch = c(2, 3, 5)[group])
text(hapax ~ words, labels = dialogue, 
     pos = 2, cex = 0.7, col = c("darkblue", "darkgreen", "darkred")[group])
```

Некоторые названия перекрываютcя (с этим мы научимся бороться позже), но все равно намного понятнее. Теперь можем поменять шрифт и, например, добавить линию регрессии (не хватает легенды, но что-то уже нет сил).

```{r message=FALSE}
attach(hapax_plato)
options(scipen=999) # избавляет от научной нотации
plot(words, hapax, log = "xy", col = c("darkblue", "darkgreen", "darkred")[group], pch = c(2, 3, 5)[group], family = "serif")
text(hapax ~ words, labels = dialogue, 
     pos = 2, cex = 0.7, col = c("darkblue", "darkgreen", "darkred")[group], family = "serif")

# добавим линию регрессии
my_lm <- lm(hapax_plato$hapax ~ hapax_plato$words)
abline(my_lm, lty = "dashed", col = "darkgrey", untf = T)

# и заголовок
title(main = "Число гапаксов в зависимости от длины диалога")
```

При помощи **графических параметров**[^02-plot-2] можно контролировать множество настроек. Но в этом и недостаток базовой графики. Не всем хватает терпения и вкуса этим заниматься, поэтому эта система сейчас не очень употребительна.

[^02-plot-2]: <https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/par>

Попробуйте интерпретировать график, который у нас получился. Прав ли был профессор Кэмпбелл, утверждая, что высокая доля гапаксов характерна для "поздних" текстов? Исходите из того, что единственный текст, о котором точно известно, что он поздний -- это "Законы".

[*Судя по графику, количество гапаксов зависит от количества слов в тексте. Чем длиннее текст, тем больше вероятность встретить там редкое слово.*]{.spoiler}

## Lattice

Система Lattice (букв. "Решетка") была разработана специально для анализа многомерных данных [@sarkar2008].

![Тут должны быть ~~графики~~ цветочки](https://t3.ftcdn.net/jpg/01/14/40/18/360_F_114401812_cxTjhkdRZfTxBGBPZGxr6D6V5HXwdwP5.jpg){ width=70% }

Например, мы сравниваем точность классификации текстов в зависимости от длины отрывка и количества слов-предикторов. Это уже три переменные (длина -- количество слов -- точность). Система решеток, или панелей, позволяет представить такие многомерные данные. 

![Многомерно нет слов!](https://github.com/locusclassicus/GreekDelta/blob/master/Plots/RplotAccuracyUnicode.png?raw=true){ width=60% }

В базовом R это тоже можно сделать, изменив графические параметры:

```{r}
par(mfrow = c(1,2)) # вот тут указываем число рядов и столбцов
plot(hapax_plato$hapax ~ hapax_plato$words)
plot(hapax_plato$ratio ~ hapax_plato$group)
```

Но видно, что пространство при этом расходуется неэффективно. Кроме того, к таким графикам сложно создавать заголовки и подзаголовки, подбирать подписи и т.п. Все эти задачи решает Lattice.

Идея этой системы в том, что каждый график строится с помощью одного вызова функции. При этом необходимо сразу указать большое количество информации, чтобы у фунцкии было достаточно данных для построения графика.

```{r message=FALSE}
library(lattice)
attach(hapax_plato)

# после вертикальной черты указана переменная, которая используется для группировки данных; в нашем случае номер группы (по Кэмпбеллу)

xyplot(hapax ~ words | group, data = hapax_plato,
       scales=list(x=list(log=10))) # трансформация по одной оси
```

Недостаток Lattice, однако, в том, что бывает сложно аннотировать отдельные панели, а также приходится сразу задавать весь график в одном вызове функции. Это не всегда удобно. После создания графика уже ничего нельзя добавить или убавить.

## Ggplot2

Но настоящая графическая сила R -- это пакет ggplot2. В его основе лежит идея "грамматики графических элементов" Лиланда Уилкинсона [@мастицкий2017], и он позволяет объединить достоинства базовой графики R и Lattice. С одной стороны, вы можете постепенно достраивать график, добавляя элемент за элементом; с другой стороны, множество параметров подбираются автоматически, как в Lattice.

### Быстрое решение: qplot()

Настройки по умолчанию хорошо видно на графике ниже; их легко перенастроить.

```{r}
library(ggplot2) # загружается сразу с tidyverse
options(scipen = 999)
qplot(words, hapax, data = hapax_plato, log = "xy")
```

Функция `qplot()` -- это быстрое решение для задач визуализации.

::: infobox
В современных версиях ggplot использование функции `qplot()` не рекомендуется (deprecated), чтобы побудить пользователей изучать `ggplot()` как более совершенный инструмент. 
:::

В данном случае мы построили диаграмму рассеяния, используя логарифмическую трансформацию по двум осям. Можно также выделить цветом различные типы диалогов, изменить размер точек, их прозначность и т.п.

```{r}
qplot(words, hapax, data = hapax_plato, log = "xy", col = group, size = 1.5) + theme(legend.position = "none")
```

**Диаграмма размаха** (о ней подробнее можно посмотреть [здесь](https://vk.com/video_ext.php?oid=-211800158&id=456239229&hash=7e1bc800e53df22c&hd=2)) удобна в тех случаях, когда необходимо представить обобщенную статистическую информацию о распределении значений количественной переменной в разных группах.

```{r warning=FALSE, message=FALSE}
attach(hapax_plato)
qplot(group, ratio, data = hapax_plato, geom = "boxplot", color = group)
```

Диаграмму размаха можно совместить с **одномерной диаграммой рассеяния**.

```{r warning=FALSE}
qplot(group, ratio, data = hapax_plato, geom = c("boxplot", "jitter"), color = group) # вместо color можно использовать shape, который отвечает за форму элементов
```

### Слой за слоем: ggplot()

Для более детальной настройки графика рекомендууется использовать функцию `ggplot()`, которая имеет два основных аргумента: `data` и `aes` (англ. *aesthetics*); последняя присваивает эстетические атрибуты геометрическим объектам, которые используются на графике. Эти объекты могут слоями накладываться друг на друга [@wickham2016].

Посмотрим, как это работает, на примере, **столбиковой диаграммы**. Такая диаграмма позволяет представить распределение как количественных, так и качественных переменных. Для примера возьмем датасет `diorisis_meta`, который хранит данные о древнегреческих текстах, доступных в репозитории Diorisis[^02-plot-3].

[^02-plot-3]: <https://figshare.com/articles/dataset/The_Diorisis_Ancient_Greek_Corpus/6187256>

```{r warning=FALSE, echo=F}
load("./data/DiorisisMeta.Rdata")
head(diorisis_meta)
```

Столбиковая диаграмма позволяет увидеть, тексты каких жанров чаще всего встречаются в этом корпусе.

```{r message=FALSE}
library(tidyverse)
diorisis_meta %>%
  group_by(genre) %>% 
  count() %>% 
  ggplot(aes(reorder(genre, n), n, fill = genre)) + 
  geom_bar(stat = "identity") + 
  coord_flip()
```

**Точечная диаграмма**, или dotplot, подходит для тех случаев, когда мы исследуем распределение наблюдений для разных групп данных, причем наблюдений не очень много. Например, мы можем отразить распределение текстов в корпусе по годам. Категориальную переменную (например, жанр) можно дополнительно закодировать цветом  ([зд. подробнее о том, что можно увидеть на этом графике](https://t.me/antibarbari/109)).

```{r}
diorisis_meta %>% ggplot(aes(date, fill = factor(genre))) + 
  geom_dotplot(binwidth = 10, stackdir = "centerwhole", binpositions = "all") +  
  scale_y_continuous(NULL, breaks = NULL) + 
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10))
```

Различные группы данных можно выделять не только цветом и формой, но и помещать каждую в свое окошко (facet). Попробуем выяснить: сколько поджанров в каждом жанре?

```{r}
diorisis_meta %>% 
  group_by(genre, subgenre) %>% 
  count %>%
  filter(genre %in% c("Poetry", "Technical")) %>% 
  ggplot(aes(reorder(subgenre, n), n, fill = subgenre)) + 
  geom_col(show.legend = F) +
  facet_wrap(~genre, scales = "free") + # вот здесь задаем  группы
  coord_flip()
```

Подробнее с разными видами графиков мы познакомимся дальше, но напоследок о том, как сделать так, чтобы текстовые подписи не наезжали друг на друга.

```{r warning=FALSE}
library(ggrepel)
hapax_plato %>% ggplot(aes(words, hapax, col = group)) +
  geom_point(size = 1.2, alpha = 0.7, show.legend = F) +
  geom_label_repel(label = dialogue) +
  scale_x_log10() +
  scale_y_log10() +
  theme_bw()
```

Ай, красота.

## Экспорт графиков из среды R

Способы:

-   реализованные в R драйверы стандартных графических устройств;
-   функция `ggsave()`
-   меню программы RStudio.

```{r eval=FALSE}
# код сохранит pdf в рабочую директорию 
pdf(file = "Diorisis.pdf")
diorisis_meta %>% 
  group_by(genre, subgenre) %>% 
  count %>%
  filter(genre %in% c("Poetry", "Technical")) %>% 
  ggplot(aes(reorder(subgenre, n), n, fill = subgenre)) + 
  geom_col(show.legend = F) +
  facet_wrap(~genre, scales = "free") +
  coord_flip()
dev.off()

# еще один способ сохранить последний график
ggsave(
  filename = "Diorisis.png",
  plot = last_plot(),
  device = "png",
  scale = 1,
  width = NA,
  height = 500,
  units = "px",
  dpi = 300
)
```
