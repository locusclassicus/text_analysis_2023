# Начало работы с R

## Что такое R?

R --- это язык программирования для статистической обработки данных и работы с графикой. Он создан в 90-х гг. на факультете статистики Оклендского университета. Иными словами, его делали статистики и для статистиков. Поэтому он прекрасно подходит для анализа данных, статистических вычислений и машинного обучения, а значит востребован в науке.

> Язык R --- один из самых распространённых в научной среде. Им пользуются математики, биологи, генетики и другие учёные, которым нужно проводить статистические исследования и строить модели. Поэтому язык R нужно изучать тем, кто планирует заниматься научными исследованиями.
>
> --- Яндекс Практикум [Блог](https://practicum.yandex.ru/blog/chto-takoe-yazyk-r/#chto-takoe)

После установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Но за счет того, что R распространяется свободно, постоянно появляются новые алгоритмы, созданные внутри экспертного сообщества и тоже доступные для всех. Как и любой язык, R растет и развивается.

## Пакеты и виньетки

Если в базовой инсталляции R нет нужного решения -- имеет смысл поискать в библиотеке **пакетов**. Пакет -- это **набор функций** и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории [CRAN](https://cran.r-project.org/) доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub, например [пакет Dracor](https://rdrr.io/github/dracor-org/rdracor/f/README.md), к которому я буду обращаться в рамках этого курса.

::: infobox
Некоторые функции, которые вы найдете в пакетах, частично дублируют друг друга -- это нормально, как и в естественном языке, "сказать" что-то можно разными способами.
:::

Несмотря на то, что R создавался изначально для работы со статистикой, система свободно распространяемых модулей значительно расширяет круг задач, которые можно решать на этом языке. Например, благодаря модулю Shiny можно создавать [приложения](https://locusclassicus.shinyapps.io/myshinyapp/) и встраивать их в веб-страницы, а модуль Leaflet позволяет создавать интерактивные карты. [Одну из них](http://antibarbari.ru/2023/03/01/cicero_villas/) мы сделали в рамках проекта Antibarbari HSE. В рамках этого курса мы познакомимся и с модулями для машинного обучения. Нейросети в R тоже можно строить, но мы пока не будем.

По технической документации и так называемым "виньеткам" можно понять, какой пакет вам нужен. Например, вот так выглядит [виньетка](https://docs.ropensci.org/rperseus/articles/rperseus-vignette.html) пакета `RPerseus`, при помощи которого можно получить доступ к корпусу греческой и латинской литературы.

Бывают еще **"пакеты пакетов"**, то есть очень большие семейства функций, своего рода "диалекты" R. Таково, например, семейство `tidyverse`, объединяемое идеологией "опрятных" данных. Про него мы еще будем говорить.

## Если не хватает пакетов

Это самое интересное. Если вы работаете в программе с графическим интерфейсом (SPSS, Minitab), то вы вынуждены формулировать свою задачу так, чтобы "вписаться" в набор кнопок, предусмотренных разработчиком. В R, столкнувшись с особой задачей, вы просто пишете под нее особую функцию.

Новую функцию не обязательно публиковать в составе пакета -- можно сохранить в рабочую директорию (с расширением `.R`) и наслаждаться самому. По мере того, как развиваются ваши навыки программирования, вы можете ставить и решать все более сложные и интересные задачи.

## О воспроизводимости

Когда вы решите опубликовать свое исследование, то и код к нему придется опубликовать (как правило, для этого используется GitHub) -- поэтому надо сразу привыкать кодить так, чтобы ваш код был понятен другим. Например, добавлять пояснения при помощи знака `#` (как в Python)

```{r}
# случайный набор чисел из нормального распределения
x <- rnorm(1000)
# случайная выборка из этого набора
y <- sample(x, 100)
```

В идеале, впрочем, вы поясняете не то, *что* код делает (при грамотном кодинге это должно быть самоочевидо), а *зачем*.

В этом примере код, правда, настолько простой, что не требует особых пояснений. Но в больших проектах от "читабельности" кода зависит не только то, поймет ли вас потенциальный рецензент, но и сможете ли вы сами вспомнить, какая строчка за что отвечает. Также это позволит вернуться к проекту через некоторое время и быстро вспомнить, что там происходит.

Если вы получите интересные результаты и решите их опубликовать, то выложить в открытый доступ придется не только код, но и данные (если они не защищены копирайтом или другими ограничениями). Таким образом рецензент или другие ученые, которые будут читать вашу статью, сможет перепроверить ваши выводы. Ученые так делают!

И это еще один довод в пользу того, чтобы научиться программировать, а не полагаться на ПО с графическим интерфейсом.

## Что мы (не) будем делать?

Хотя возможности R очень широки, мы будем заниматься в основном анализом текстовых данных. "Текст" в данном случае можно понимать как зафиксированную (в машиночитаемом виде) речь: от отзыва на товар до романа. Но в основном данные я подбираю таким образом, чтобы они были интересны гуманитариям.

Мы *не будем* анализировать звучащую речь (хотя это тоже [можно делать](https://ling.hse.ru/news/671710245.html) в R). И мы не будем заниматься распознаванием рукописных символов, для этого есть гораздо другие [мощные инструменты](https://vk.com/video-211800158_456239315). Веб-скрапинг и нейронные сети тоже не входят в число тем этого курса.

Курс включает в себя три основных блока и 24 урока:

-   общее введение в R (темы 1-6)
-   text-mining (темы 7-13)
-   статистика и статистическое обучение (14-22)

Еще два урока посвящены модулям Plotly и Leaflet.

Если вы плохо представляете, на что вообще способны количественные методы в гуманитаристике, посмотрите видео панельной дискуссии ["Цифровые инструменты и методы: в чем их польза и как им обучить гуманитария?"](https://vk.com/video-211800158_456239307) (НИУ ВШЭ, 2023 г.). Это видео о том, зачем. О том, как -- дальше.

## RStudio

Работать в R мы будем с использованием RStudio, которая представляет собой свободную среду разработки (IDE) программного обеспечения с открытым исходным кодом для языка программирования R.

Наша задача в этом уроке -- установить R и R Studio и убедиться, что все работает; научиться самостоятельно находить помощь, совершать несложные вычисления.

## Установка

1.  Установить R

-   Скачать R для Windows: <https://cran.r-project.org/bin/windows/>
-   Скачать R для Mac: <https://cran.r-project.org/bin/macosx/>

2.  Установить R Studio

-   Скачать: <https://www.rstudio.com/products/rstudio/download/> (достаточно бесплатной версии)

::: infobox
На MacOS для работы библиотеки Stylo также понадобится установить XQuartz: <https://www.xquartz.org/>
:::

## Начало работы

После установки и запуска RStudio вы увидите вот такие четыре панели (их названия подписаны на картинке):

![RStudio Panes](https://docs.posit.co/ide/user/ide/guide/ui/images/rstudio-panes-labeled.jpeg)

По [ссылке](https://docs.posit.co/ide/user/ide/guide/ui/ui-panes.html) можно подробнее прочитать, что за что отвечает (и как это поменять).

Для начала попробуйте получить информацию о сессии, введя в **консоли** такую команду:

```{r eval=FALSE}
sessionInfo()
```

`sessionInfo()` -- это **функция**. За названием функции всегда следуют круглые скобки, внутри которых могут находиться **аргументы функции**. О функциях можно думать как о глаголах ("сделай то-то!"). Аргументы -- это что-то вроде дополнений и обстоятельств. (Кстати, в "диалекте" tidyverse есть функции-наречия, так что аналогия законная.) Аргументы могут быть обязательные и необязательные.

::: infobox
Чтобы узнать, каких аргументов требует функция, надо вызывать **help**: `?mean()`. Также можно (и нужно) читать техническую документацию к пакетам.
:::

Уточнить свою **рабочую директорию** (в которой R будет искать и сохранять файлы) можно при помощи функции `getwd()` без аргументов. Установить рабочую директорию можно при помощи функции `setwd()`, указав в качестве аргумента путь к рабочей директории на вашем компьютере (в кавычках, так как это символьный вектор). В моем случае это выглядит так:

```{r eval=FALSE}
setwd("/Users/olga/R_Workflow/")
```

Также для выбора рабочей директории можно использовать меню R `Session > Set Working Directory`.

Пакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню `Tools > Install Packages`. Также можно устанавливать пакеты из консоли. Установим пакет для стилометрического анализа:

```{r eval=FALSE}
install.packages("stylo")
```

Для подключения используем функцию `library()`, которой передаем в качестве аргумента название пакета без кавычек:

```{r eval=FALSE}
library(stylo)
```

Что еще надо знать:

-   как создавать проекты в R и почему это удобно [^01-intro-1]
-   как создавать и хранить файлы с кодом

[^01-intro-1]: <https://intro2r.com/rsprojs.html>

## R как калькулятор

Можно использовать R как калькулятор. Для этого вводим данные рядом с символом приглашения `>`, который называется **prompt**.

```{r}
sqrt(4) # квадратный корень
2^3 # степень
log10(100) #логарифм
```

Если в начале консольной строки стоит `+`, значит предыдущий код не завершен. Например, вы забыли закрыть скобку функции. Ее можно дописать на следующей строке. Попробуйте набрать `sqrt(2` в консоли.

## Операторы присваивания

Чтобы в окружении появился новый объект, надо присвоить результат вычислений какой-нибудь переменной при помощи **оператора присваивания** `<-` (`Alt` + `-` (Windows) или `Option` + `-` (Mac)). Знак `=` также работает как оператор присваивания, но не во всех контекстах, поэтому им лучше не пользоваться.

```{r}
x <- 2 + 2 # создаем переменную
y <- 0.1 # создаем еще одну переменную
x <- y # переназначаем  
x + y
```

**Имя переменной**, как и имя функции, может содержать прописные и строчные буквы, точку и знак подчеркивания. Функция `c()` (concatenation) позволяет собрать несколько элементов в единый вектор:

```{r}
x <- c(3, 5, 7)
x_mean <- mean(x) # также возможно x.mean или xMean
x_mean
```

В диалекте tidyverse предпочтение отдается подчеркиванию, а не точке; здесь сказывается влияние синтаксиса Python, где через точку получают доступ к методам объекта. Будьте внимательны: R чувствительна к регистру!

::: infobox
**Объекты, предназначенные для хранения данных**, -- это отдельные переменные, векторы, матрицы и массивы, списки, факторы, таблицы данных. **Функции** -- это поименованные программы, предназначенные для создания новых объектов или выполнения определенных действий над ними [@мастицкий2015, 24]
:::

Чтобы получить список всех объектов в окружении, используется функция `ls()`. Удалять объекты можно при помощи `rm()`. Функции можно вкладывать друг в друга:

```{r eval=FALSE}
rm(list = ls()) # удаляет все объекты в окружении
```

## Векторы

В языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента.

```{r}
x <- 2
class(x) # числовой вектор
length(x) # длина вектора

y <- c() # создадим пустой вектор
y # при попытке распечатать получаем NULL 
length(y) # длина равна 0
```

::: infobox
`NULL` означает, что значение не существует; `NA` (not available) -- что оно существует, но неизвестно. Поэтому `mean(c(1, NA, 2))` выдаст ошибку, а `mean(c(1, NULL, 2))` вернет среднее. В первом случае можно использовать дополнительный аргумент: `mean(c(1, NA, 2), na.rm=T)`. Подробнее см. [@мэтлофф2019].
:::

Основные типы данных, с которыми мы будем работать, следующие:

-   целое число (integer)
-   число с плавающей точкой (numeric, также называются double, то есть число двойной точности)
-   строка (character)
-   логическая переменная (logical)
-   категориальная переменная, или фактор (factor)

```{r}
# проверить тип данных 
x <- sqrt(2)
class(x)
is.integer(x)
is.numeric(x)
```

При попытке объединить в единый вектор данные разных типов, они будут принудительно приведены к одному типу:

```{r}
x <- c(TRUE, 1, 3, FALSE)
x # логические значения переработаны в числовые

y <- c(1, "a", 2, "лукоморье") # строки всегда в кавычках
y # числа превратились в строки
```

![Типы векторов в R](https://d33wubrfki0l68.cloudfront.net/1d1b4e1cf0dc5f6e80f621b0225354b0addb9578/6ee1c/diagrams/data-structures-overview.png){width="60%"}

Логические векторы можно получить в результате применения **логических выражений** (`==` "равно", `!=` "не равно", `<=` "меньше или равно") к данным других типов:

```{r}
x <- c(1:10) # числа от 1 до 10
y <- x > 5
y # значения TRUE соответствуют единице, поэтому их можно складывать
sum(y)
```

Функции `all()` и `any()` также возвращают логические значения:

```{r}
x <- 10:20 
any(x == 15)
all(x > 9)
```

Существуют различные способы сгенерировать векторы:

```{r}
seq(1, 5, 0.5)
rep("foo", 5)
```

Векторы можно индексировать, то есть забирать из них какие-то элементы:

```{r}
x <- seq(1, 5, 0.5)
x[4:5] # индексы начинаются с 1 (в отличие от Python)
```

Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет **переработан**, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины.

```{r}
x <- 2; y <- c(10, 20, 30); z <- c(5, 6, 7)
y / x 
x + y 
y + z
```

**Факторы** внешне похожи на строки, но в отличие от них хранят информацию об *уровнях* категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой.

```{r}
t <- factor(c("A", "B", "C"), levels = c("A", "B", "C"))
t
```

## Списки

Списки, или рекурсивные векторы (в отличие от атомарных векторов), могут хранить данные разных типов.

```{r}
list = list(a = c("a", "b", "c"), b = c(1, 2, 3), c = c(T, F, T))
list
```

Можно получить доступ как к элементам списка целиком, так и к их содержимому.

```{r}
list$a # обращение к поименованным элементам 

list[2] # одинарные квадратные скобки извлекают элемент списка целиком
class(list[2])

list[[2]] #  элементы второго элемента 
class(list[[2]])

list$c[1]# первый элемент второго элемента
```

Обратите внимание, что `list[2]` и `list[[2]]` возвращают объекты разных классов. Нам это еще понадобится при работе с XML.

![Индексирование списка в R](https://d33wubrfki0l68.cloudfront.net/2f3f752cae25018554d484464f117e600ff365a2/37627/diagrams/lists-subsetting.png)

Если пройти по [ссылке](https://r4ds.had.co.nz/vectors.html#subsetting-1), можно увидеть еще несколько замечательных иллюстраций этой мысли🧂

## Матрицы

Матрица -- это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
M # все ок

M = matrix(c(1, 2, 3, "a"), nrow = 2)
M # все превратилось в строку! 
```

В матрице есть строки и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер строки, потом номер столбца.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
M[1, ] # первая строка полностью
M[,2] # второй столбец полностью
M[1,1] # одно значение
```

Обратите внимание, как меняется размерность при индексировании.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
class(M)
dim(M) # функция для извлечения измерений

class(M[1, ]) # первая строка полностью
dim(M[1, ]) 
```

Попытка узнать измерения вектора возвращает `NULL`, потому что с точки зрения R векторы не являются матрицами из одного столбца или одной строки, и потому не имеют измерений. С другой стороны, можно создать матрицу, в которой будет одна строка или один столбцец. При выводе они выглядят не так, как обычные векторы. Хотя казалось бы.

```{r}
# вектор-строка
C = matrix(c(1, 2, 3), nrow = 1)
C

# вектор-столбец
D = matrix(c(1, 2, 3), nrow = 3)
D
```

Над числовыми матрицами в R можно совершать разные операции из линейной алгебры; многие из них нам понадобятся, когда мы будем говорить о латентно-семантическом анализе.

Пока лишь несколько полезных функций.

```{r}
# в квадратной матрице есть главная и побочная диагонали
M = matrix(c(1, 2, 3, 4), nrow = 2) # ее мы распечатывали выше
diag(M)

# если поставить матрицу на бок, то получится транспонированная матрица
t(M)

# матрицу можно умножить на скаляр, то есть на обычное число. 
M * 3

# матрицы одного размера можно складывать
M + M
```

Матрицы также можно умножать на другие матрицы и на векторы. Но это уже линан, и мы вернемся к этому в другой раз. Пока, если хотите, можете посмотреть [видео](https://vk.com/video-211800158_456239317).

Подробнее об элементах линейной алгебры в R см. [@буховец2015].

## Таблицы

Таблицы (кадры данных, data frames) -- это двумерные объекты (как и матрицы). Датафреймы отличаются от матриц тем, что их столбцы могут хранить данные разного типа.

:::infobox
Если списки являются разнородными аналогами векторов в одном измерении, кадры данных являются разнородными аналогами матриц для двухмерных данных [@мэтлофф2019, 133].
:::

```{r}
# создание датафрейма
df <- data.frame(names = c("A", "B"), age = c(10, 11))
df

# извлечение элементов
df$names # забирает весь столбец
df[,"names"] # то же самое, другой способ
df[1, ] # забирает ряд
```

Потренируемся на датасете с данными о гапаксах в диалогах Платона.

::: infobox
Гапакс -- это слово, которое встречается один раз в корпусе или тексте.
:::

Этот датасет позволяет перепроверить выводы Льюиса Кэмпбелла, профессора Сент-Эндрюсского университета в Шотландии. Еще 1867 г., впервые применив количественный метод для датировки диалогов Платона, он пришел к выводу, что для "позднего" стиля Платона, среди прочего, характерно обилие редкой лексики [@campbell1867, xxxi].

В корпус подлинных диалогов Кэмпбелл включал 26 текстов, которые делил на три хронологические группы. Свои вычисления он делал вручную, а мы можем попробовать все пересчитать в R.

```{r echo = F}
load(file = "datasets/HapaxPlato.Rdata")
head(hapax_plato)
```

Вот так выглядят наши данные. Функция `class()` позволяет убедиться, что это датафрейм.

```{r echo = F}
class(hapax_plato)
```

Потренируемся работать с данными в таблицах.

```{r}
# узнать имена столбцов
colnames(hapax_plato) 

# извлечь ряд(ы) по значению
hapax_plato[hapax_plato$dialogue == "Parmenides", ] 

# узнать тип данных в столбцах
str(hapax_plato) 

# отобрать ряды по количеству слов
hapax_plato[hapax_plato$words > 10000, ]

# преобразовать тип данных в столбцах
hapax_plato$group <- as.factor(hapax_plato$group)
hapax_plato[,2:4] <- sapply(hapax_plato[,2:4],as.numeric) # подробнее о функции `sapply()` в уроке про итерации
```

И еще с датафреймами полезна функция `summary()`:

```{r}
summary(hapax_plato)
```

## Шорткаты

Этот раздел я допишу позже.
