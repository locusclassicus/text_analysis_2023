[["index.html", "A Minimal Book Example Тема 1 About 1.1 Usage 1.2 Render book 1.3 Preview book", " A Minimal Book Example John Doe 2023-07-14 Тема 1 About This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports; for example, a math equation \\(a^2 + b^2 = c^2\\). 1.1 Usage Each bookdown chapter is an .Rmd file, and each .Rmd file can contain one (and only one) chapter. A chapter must start with a first-level heading: # A good chapter, and can contain one (and only one) first-level heading. Use second-level and higher headings within chapters like: ## A short section or ### An even shorter section. The index.Rmd file is required, and is also your first book chapter. It will be the homepage when you render the book. 1.2 Render book You can render the HTML version of this example book without changing anything: Find the Build pane in the RStudio IDE, and Click on Build Book, then select your output format, or select “All formats” if you’d like to use multiple formats from the same book source files. Or build the book from the R console: bookdown::render_book() To render this example to PDF as a bookdown::pdf_book, you’ll need to install XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. 1.3 Preview book As you work, you may start a local server to live preview this HTML book. This preview will update as you edit the book when you save individual .Rmd files. You can start the server in a work session by using the RStudio add-in “Preview book”, or from the R console: bookdown::serve_book() "],["начало-работы-с-r.html", "Тема 2 Начало работы с R 2.1 Что такое R? 2.2 Пакеты и виньетки 2.3 Если не хватает пакетов 2.4 О воспроизводимости 2.5 Что мы (не) будем делать? 2.6 RStudio 2.7 Установка 2.8 Начало работы 2.9 R как калькулятор 2.10 Операторы присваивания 2.11 Векторы 2.12 Списки 2.13 Матрицы 2.14 Таблицы 2.15 Шорткаты", " Тема 2 Начало работы с R 2.1 Что такое R? R — это язык программирования для статистической обработки данных и работы с графикой. Он создан в 90-х гг. на факультете статистики Оклендского университета. Иными словами, его делали статистики и для статистиков. Поэтому он прекрасно подходит для анализа данных, статистических вычислений и машинного обучения, а значит востребован в науке. Язык R — один из самых распространённых в научной среде. Им пользуются математики, биологи, генетики и другие учёные, которым нужно проводить статистические исследования и строить модели. Поэтому язык R нужно изучать тем, кто планирует заниматься научными исследованиями. — Яндекс Практикум Блог После установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Но за счет того, что R распространяется свободно, постоянно появляются новые алгоритмы, созданные внутри экспертного сообщества и тоже доступные для всех. Как и любой язык, R растет и развивается. 2.2 Пакеты и виньетки Если в базовой инсталляции R нет нужного решения – имеет смысл поискать в библиотеке пакетов. Пакет – это набор функций и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории CRAN доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub, например пакет Dracor, к которому я буду обращаться в рамках этого курса. Некоторые функции, которые вы найдете в пакетах, частично дублируют друг друга – это нормально, как и в естественном языке, “сказать” что-то можно разными способами. Несмотря на то, что R создавался изначально для работы со статистикой, система свободно распространяемых модулей значительно расширяет круг задач, которые можно решать на этом языке. Например, благодаря модулю Shiny можно создавать приложения и встраивать их в веб-страницы, а модуль Leaflet позволяет создавать интерактивные карты. Одну из них мы сделали в рамках проекта Antibarbari HSE. В рамках этого курса мы познакомимся и с модулями для машинного обучения. Нейросети в R тоже можно строить, но мы пока не будем. По технической документации и так называемым “виньеткам” можно понять, какой пакет вам нужен. Например, вот так выглядит виньетка пакета RPerseus, при помощи которого можно получить доступ к корпусу греческой и латинской литературы. Бывают еще “пакеты пакетов”, то есть очень большие семейства функций, своего рода “диалекты” R. Таково, например, семейство tidyverse, объединяемое идеологией “опрятных” данных. Про него мы еще будем говорить. 2.3 Если не хватает пакетов Это самое интересное. Если вы работаете в программе с графическим интерфейсом (SPSS, Minitab), то вы вынуждены формулировать свою задачу так, чтобы “вписаться” в набор кнопок, предусмотренных разработчиком. В R, столкнувшись с особой задачей, вы просто пишете под нее особую функцию. Новую функцию не обязательно публиковать в составе пакета – можно сохранить в рабочую директорию (с расширением .R) и наслаждаться самому. По мере того, как развиваются ваши навыки программирования, вы можете ставить и решать все более сложные и интересные задачи. 2.4 О воспроизводимости Когда вы решите опубликовать свое исследование, то и код к нему придется опубликовать (как правило, для этого используется GitHub) – поэтому надо сразу привыкать кодить так, чтобы ваш код был понятен другим. Например, добавлять пояснения при помощи знака # (как в Python) # случайный набор чисел из нормального распределения x &lt;- rnorm(1000) # случайная выборка из этого набора y &lt;- sample(x, 100) В идеале, впрочем, вы поясняете не то, что код делает (при грамотном кодинге это должно быть самоочевидо), а зачем. В этом примере код, правда, настолько простой, что не требует особых пояснений. Но в больших проектах от “читабельности” кода зависит не только то, поймет ли вас потенциальный рецензент, но и сможете ли вы сами вспомнить, какая строчка за что отвечает. Также это позволит вернуться к проекту через некоторое время и быстро вспомнить, что там происходит. Если вы получите интересные результаты и решите их опубликовать, то выложить в открытый доступ придется не только код, но и данные (если они не защищены копирайтом или другими ограничениями). Таким образом рецензент или другие ученые, которые будут читать вашу статью, сможет перепроверить ваши выводы. Ученые так делают! И это еще один довод в пользу того, чтобы научиться программировать, а не полагаться на ПО с графическим интерфейсом. 2.5 Что мы (не) будем делать? Хотя возможности R очень широки, мы будем заниматься в основном анализом текстовых данных. “Текст” в данном случае можно понимать как зафиксированную (в машиночитаемом виде) речь: от отзыва на товар до романа. Но в основном данные я подбираю таким образом, чтобы они были интересны гуманитариям. Мы не будем анализировать звучащую речь (хотя это тоже можно делать в R). И мы не будем заниматься распознаванием рукописных символов, для этого есть гораздо другие мощные инструменты. Веб-скрапинг и нейронные сети тоже не входят в число тем этого курса. Курс включает в себя три основных блока и 24 урока: общее введение в R (темы 1-6) text-mining (темы 7-13) статистика и статистическое обучение (14-22) Еще два урока посвящены модулям Plotly и Leaflet. Если вы плохо представляете, на что вообще способны количественные методы в гуманитаристике, посмотрите видео панельной дискуссии “Цифровые инструменты и методы: в чем их польза и как им обучить гуманитария?” (НИУ ВШЭ, 2023 г.). Это видео о том, зачем. О том, как – дальше. 2.6 RStudio Работать в R мы будем с использованием RStudio, которая представляет собой свободную среду разработки (IDE) программного обеспечения с открытым исходным кодом для языка программирования R. Наша задача в этом уроке – установить R и R Studio и убедиться, что все работает; научиться самостоятельно находить помощь, совершать несложные вычисления. 2.7 Установка Установить R Скачать R для Windows: https://cran.r-project.org/bin/windows/ Скачать R для Mac: https://cran.r-project.org/bin/macosx/ Установить R Studio Скачать: https://www.rstudio.com/products/rstudio/download/ (достаточно бесплатной версии) На MacOS для работы библиотеки Stylo также понадобится установить XQuartz: https://www.xquartz.org/ 2.8 Начало работы После установки и запуска RStudio вы увидите вот такие четыре панели (их названия подписаны на картинке): RStudio Panes По ссылке можно подробнее прочитать, что за что отвечает (и как это поменять). Для начала попробуйте получить информацию о сессии, введя в консоли такую команду: sessionInfo() sessionInfo() – это функция. За названием функции всегда следуют круглые скобки, внутри которых могут находиться аргументы функции. О функциях можно думать как о глаголах (“сделай то-то!”). Аргументы – это что-то вроде дополнений и обстоятельств. (Кстати, в “диалекте” tidyverse есть функции-наречия, так что аналогия законная.) Аргументы могут быть обязательные и необязательные. Чтобы узнать, каких аргументов требует функция, надо вызывать help: ?mean(). Также можно (и нужно) читать техническую документацию к пакетам. Уточнить свою рабочую директорию (в которой R будет искать и сохранять файлы) можно при помощи функции getwd() без аргументов. Установить рабочую директорию можно при помощи функции setwd(), указав в качестве аргумента путь к рабочей директории на вашем компьютере (в кавычках, так как это символьный вектор). В моем случае это выглядит так: setwd(&quot;/Users/olga/R_Workflow/&quot;) Также для выбора рабочей директории можно использовать меню R Session &gt; Set Working Directory. Пакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню Tools &gt; Install Packages. Также можно устанавливать пакеты из консоли. Установим пакет для анализа лингвистических данных: install.packages(&quot;languageR&quot;) Для подключения используем функцию library(), которой передаем в качестве аргумента название пакета без кавычек: library(languageR) Что еще надо знать: как создавать проекты в R и почему это удобно 1 как создавать и хранить файлы с кодом 2.9 R как калькулятор Можно использовать . Для этого вводим данные рядом с символом приглашения &gt;, который называется prompt. sqrt(4) # квадратный корень ## [1] 2 2^3 # степень ## [1] 8 log10(100) #логарифм ## [1] 2 Если в начале консольной строки стоит +, значит предыдущий код не завершен. Например, вы забыли закрыть скобку функции. Ее можно дописать на следующей строке. Попробуйте набрать sqrt(2 в консоли. 2.10 Операторы присваивания Чтобы в окружении появился новый объект, надо присвоить результат вычислений какой-нибудь переменной при помощи оператора присваивания &lt;- (Alt + - (Windows) или Option + - (Mac)). Знак = также работает как оператор присваивания, но не во всех контекстах, поэтому им лучше не пользоваться. x &lt;- 2 + 2 # создаем переменную y &lt;- 0.1 # создаем еще одну переменную x &lt;- y # переназначаем значение x + y ## [1] 0.2 Имя переменной, как и имя функции, может содержать прописные и строчные буквы, точку и знак подчеркивания. Функция c() (concatenation) позволяет собрать несколько элементов в единый вектор: x &lt;- c(3, 5, 7) x_mean &lt;- mean(x) # также возможно x.mean или xMean x_mean ## [1] 5 В диалекте tidyverse предпочтение отдается подчеркиванию, а не точке; здесь сказывается влияние синтаксиса Python, где через точку получают доступ к методам объекта. Будьте внимательны: R чувствительна к регистру! Объекты, предназначенные для хранения данных, – это отдельные переменные, векторы, матрицы и массивы, списки, факторы, таблицы данных. Функции – это поименованные программы, предназначенные для создания новых объектов или выполнения определенных действий над ними (мастицкий2015?) Чтобы получить список всех объектов в окружении, используется функция ls(). Удалять объекты можно при помощи rm(). Функции можно вкладывать друг в друга: rm(list = ls()) # удаляет все объекты в окружении 2.11 Векторы В языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента. x &lt;- 2 class(x) # числовой вектор ## [1] &quot;numeric&quot; length(x) # длина вектора ## [1] 1 y &lt;- c() # создадим пустой вектор y # при попытке распечатать получаем NULL ## NULL length(y) # длина равна 0 ## [1] 0 NULL означает, что значение не существует; NA (not available) – что оно существует, но неизвестно. Поэтому mean(c(1, NA, 2)) выдаст ошибку, а mean(c(1, NULL, 2)) вернет среднее. В первом случае можно использовать дополнительный аргумент: mean(c(1, NA, 2), na.rm=T). Подробнее см. (мэтлофф2019?). Основные типы данных, с которыми мы будем работать, следующие: целое число (integer) число с плавающей точкой (numeric, также называются double, то есть число двойной точности) строка (character) логическая переменная (logical) категориальная переменная, или фактор (factor) # проверить тип данных x &lt;- sqrt(2) typeof(x) ## [1] &quot;double&quot; is.integer(x) ## [1] FALSE is.numeric(x) ## [1] TRUE При попытке объединить в единый вектор данные разных типов, они будут принудительно приведены к одному типу: x &lt;- c(TRUE, 1, 3, FALSE) x # логические значения переработаны в числовые ## [1] 1 1 3 0 y &lt;- c(1, &quot;a&quot;, 2, &quot;лукоморье&quot;) # строки всегда в кавычках y # числа превратились в строки ## [1] &quot;1&quot; &quot;a&quot; &quot;2&quot; &quot;лукоморье&quot; Добавить ссылку: Типы векторов в R Логические векторы можно получить в результате применения логических выражений (== “равно”, != “не равно”, &lt;= “меньше или равно”) к данным других типов: x &lt;- c(1:10) # числа от 1 до 10 y &lt;- x &gt; 5 y # значения TRUE соответствуют единице, поэтому их можно складывать ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE sum(y) ## [1] 5 Функции all() и any() также возвращают логические значения: x &lt;- 10:20 any(x == 15) ## [1] TRUE all(x &gt; 9) ## [1] TRUE Существуют различные способы сгенерировать векторы: seq(1, 5, 0.5) ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 rep(&quot;foo&quot;, 5) ## [1] &quot;foo&quot; &quot;foo&quot; &quot;foo&quot; &quot;foo&quot; &quot;foo&quot; Векторы можно индексировать, то есть забирать из них какие-то элементы: x &lt;- seq(1, 5, 0.5) x[4:5] # индексы начинаются с 1 (в отличие от Python) ## [1] 2.5 3.0 Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет переработан, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины. x &lt;- 2; y &lt;- c(10, 20, 30); z &lt;- c(5, 6, 7) y / x ## [1] 5 10 15 x + y ## [1] 12 22 32 y + z ## [1] 15 26 37 Отдельно несколько слов про факторы. Факторы внешне похожи на строки, но в отличие от них хранят информацию об уровнях категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой. t &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) t ## [1] A B C ## Levels: A B C 2.12 Списки Списки, или рекурсивные векторы (в отличие от атомарных векторов), могут хранить данные разных типов. list = list(a = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), b = c(1, 2, 3), c = c(T, F, T)) list ## $a ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## $b ## [1] 1 2 3 ## ## $c ## [1] TRUE FALSE TRUE Можно получить доступ как к элементам списка целиком, так и к их содержимому. list$a # обращение к поименованным элементам ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; list[2] # одинарные квадратные скобки извлекают элемент списка целиком ## $b ## [1] 1 2 3 class(list[2]) ## [1] &quot;list&quot; list[[2]] # элементы второго элемента ## [1] 1 2 3 class(list[[2]]) ## [1] &quot;numeric&quot; list$c[1]# первый элемент второго элемента ## [1] TRUE Обратите внимание, что list[2] и list[[2]] возвращают объекты разных классов. Нам это еще понадобится при работе с XML. Добавить картинку: Индексирование списка в R Если пройти по ссылке под картинкой, можно увидеть еще несколько замечательных иллюстраций этой мысли🧂. 2.13 Матрицы Матрица – это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим. M = matrix(c(1, 2, 3, 4), nrow = 2) M # все ок ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 M = matrix(c(1, 2, 3, &quot;a&quot;), nrow = 2) M # все превратилось в строку! ## [,1] [,2] ## [1,] &quot;1&quot; &quot;3&quot; ## [2,] &quot;2&quot; &quot;a&quot; В матрице есть строки и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер строки, потом номер столбца. M = matrix(c(1, 2, 3, 4), nrow = 2) M[1, ] # первая строка полностью ## [1] 1 3 M[,2] # второй столбец полностью ## [1] 3 4 M[1,1] # одно значение ## [1] 1 Обратите внимание, как меняется размерность при индексировании. M = matrix(c(1, 2, 3, 4), nrow = 2) class(M) ## [1] &quot;matrix&quot; &quot;array&quot; dim(M) # функция для извлечения измерений ## [1] 2 2 class(M[1, ]) # первая строка полностью ## [1] &quot;numeric&quot; dim(M[1, ]) ## NULL Попытка узнать измерения вектора возвращает NULL, потому что с точки зрения R векторы не являются матрицами из одного столбца или одной строки, и потому не имеют измерений. С другой стороны, можно создать матрицу, в которой будет одна строка или один столбцец. При выводе они выглядят не так, как обычные векторы. Хотя казалось бы. # вектор-строка C = matrix(c(1, 2, 3), nrow = 1) C ## [,1] [,2] [,3] ## [1,] 1 2 3 # вектор-столбец D = matrix(c(1, 2, 3), nrow = 3) D ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 Над числовыми матрицами в R можно совершать разные операции из линейной алгебры; многие из них нам понадобятся, когда мы будем говорить о латентно-семантическом анализе. Пока лишь несколько полезных функций. # в квадратной матрице есть главная и побочная диагонали M = matrix(c(1, 2, 3, 4), nrow = 2) # ее мы распечатывали выше diag(M) ## [1] 1 4 # если поставить матрицу на бок, то получится транспонированная матрица t(M) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 # матрицу можно умножить на скаляр, то есть на обычное число. M * 3 ## [,1] [,2] ## [1,] 3 9 ## [2,] 6 12 # матрицы одного размера можно складывать M + M ## [,1] [,2] ## [1,] 2 6 ## [2,] 4 8 Матрицы также можно умножать на другие матрицы и на векторы. Но это уже линан, и мы вернемся к этому в другой раз. Пока, если хотите, можете посмотреть видео. Операции с матрицами: сложение и умножение, транспонирование. Диагональная матрица Подробнее об элементах линейной алгебры в R см. (буховец2015?). 2.14 Таблицы Таблицы (кадры данных, data frames) – это двумерные объекты (как и матрицы). Датафреймы отличаются от матриц тем, что их столбцы могут хранить данные разного типа. Если списки являются разнородными аналогами векторов в одном измерении, кадры данных являются разнородными аналогами матриц для двухмерных данных. — (мэтлофф2019?). # создание датафрейма df &lt;- data.frame(names = c(&quot;A&quot;, &quot;B&quot;), age = c(10, 11)) df ## names age ## 1 A 10 ## 2 B 11 # извлечение элементов df$names # забирает весь столбец ## [1] &quot;A&quot; &quot;B&quot; df[,&quot;names&quot;] # то же самое, другой способ ## [1] &quot;A&quot; &quot;B&quot; df[1, ] # забирает ряд ## names age ## 1 A 10 Потренируемся на датасете с данными о гапаксах в диалогах Платона. Гапакс – это слово, которое встречается один раз в корпусе. Этот датасет позволяет перепроверить выводы Льюиса Кэмпбелла, профессора Сент-Эндрюсского университета в Шотландии. Еще 1867 г., впервые применив количественный метод для датировки диалогов Платона, он пришел к выводу, что для “позднего” стиля Платона, среди прочего, характерно обилие редкой лексики (campbell1867?, xxxi). В корпус подлинных диалогов Кэмпбелл включал 26 текстов, которые делил на три хронологические группы. Свои вычисления он делал вручную, а мы можем попробовать все пересчитать в R. ## dialogue words hapax ratio group ## 1 Apology 8745 36 0.004 1 ## 2 Charmides 8311 31 0.004 1 ## 3 Cratylus 17944 122 0.007 1 ## 4 Critias 4950 104 0.021 3 ## 5 Crito 4169 19 0.005 1 ## 6 Euthydemus 12453 87 0.007 1 ## 7 Euthyphro 5181 15 0.003 1 ## 8 Gorgias 26337 125 0.005 1 ## 9 HippiasMinor 4360 12 0.003 1 ## 10 Ion 4024 32 0.008 1 ## 11 Laches 7674 27 0.004 1 ## 12 Laws 103193 914 0.009 3 ## 13 Lysis 6980 49 0.007 1 ## 14 Menexenus 4808 43 0.009 1 ## 15 Meno 9791 30 0.003 1 ## 16 Parmenides 15155 20 0.001 2 ## 17 Phaedo 21825 140 0.006 1 ## 18 Phaedrus 16645 228 0.014 2 ## 19 Philebus 17668 64 0.004 3 ## 20 Protagoras 17795 102 0.006 1 ## 21 Republic 88878 668 0.008 2 ## 22 Sophist 16024 107 0.007 3 ## 23 Statesman 16953 180 0.011 3 ## 24 Symposium 17461 127 0.007 1 ## 25 Theaetetus 22489 162 0.007 2 ## 26 Timaeus 23662 370 0.016 3 Вот так выглядят наши данные. Функция class() позволяет убедиться, что это датафрейм. ## [1] &quot;data.frame&quot; Потренируемся работать с данными в таблицах. # узнать имена столбцов colnames(hapax_plato) ## [1] &quot;dialogue&quot; &quot;words&quot; &quot;hapax&quot; &quot;ratio&quot; &quot;group&quot; # извлечь ряд(ы) по значению hapax_plato[hapax_plato$dialogue == &quot;Parmenides&quot;, ] ## dialogue words hapax ratio group ## 16 Parmenides 15155 20 0.001 2 # узнать тип данных в столбцах str(hapax_plato) ## &#39;data.frame&#39;: 26 obs. of 5 variables: ## $ dialogue: chr &quot;Apology&quot; &quot;Charmides&quot; &quot;Cratylus&quot; &quot;Critias&quot; ... ## $ words : chr &quot;8745&quot; &quot;8311&quot; &quot;17944&quot; &quot;4950&quot; ... ## $ hapax : chr &quot;36&quot; &quot;31&quot; &quot;122&quot; &quot;104&quot; ... ## $ ratio : chr &quot;0.004&quot; &quot;0.004&quot; &quot;0.007&quot; &quot;0.021&quot; ... ## $ group : num 1 1 1 3 1 1 1 1 1 1 ... # отобрать ряды по количеству слов hapax_plato[hapax_plato$words &gt; 10000, ] ## dialogue words hapax ratio group ## 1 Apology 8745 36 0.004 1 ## 2 Charmides 8311 31 0.004 1 ## 3 Cratylus 17944 122 0.007 1 ## 4 Critias 4950 104 0.021 3 ## 5 Crito 4169 19 0.005 1 ## 6 Euthydemus 12453 87 0.007 1 ## 7 Euthyphro 5181 15 0.003 1 ## 8 Gorgias 26337 125 0.005 1 ## 9 HippiasMinor 4360 12 0.003 1 ## 10 Ion 4024 32 0.008 1 ## 11 Laches 7674 27 0.004 1 ## 12 Laws 103193 914 0.009 3 ## 13 Lysis 6980 49 0.007 1 ## 14 Menexenus 4808 43 0.009 1 ## 15 Meno 9791 30 0.003 1 ## 16 Parmenides 15155 20 0.001 2 ## 17 Phaedo 21825 140 0.006 1 ## 18 Phaedrus 16645 228 0.014 2 ## 19 Philebus 17668 64 0.004 3 ## 20 Protagoras 17795 102 0.006 1 ## 21 Republic 88878 668 0.008 2 ## 22 Sophist 16024 107 0.007 3 ## 23 Statesman 16953 180 0.011 3 ## 24 Symposium 17461 127 0.007 1 ## 25 Theaetetus 22489 162 0.007 2 ## 26 Timaeus 23662 370 0.016 3 # преобразовать тип данных в столбцах hapax_plato$group &lt;- as.factor(hapax_plato$group) hapax_plato[,2:4] &lt;- sapply(hapax_plato[,2:4],as.numeric) И еще с датафреймами полезна функция summary(): summary(hapax_plato) ## dialogue words hapax ratio group ## Length:26 Min. : 4024 Min. : 12.00 Min. :0.001000 1:16 ## Class :character 1st Qu.: 7154 1st Qu.: 31.25 1st Qu.:0.004000 2: 4 ## Mode :character Median : 15590 Median : 94.50 Median :0.007000 3: 6 ## Mean : 19364 Mean :146.69 Mean :0.007154 ## 3rd Qu.: 17907 3rd Qu.:136.75 3rd Qu.:0.008000 ## Max. :103193 Max. :914.00 Max. :0.021000 2.15 Шорткаты Этот раздел я допишу позже. https://intro2r.com/rsprojs.html↩︎ "],["визуализации.html", "Тема 3 Визуализации 3.1 Базовый R 3.2 Lattice 3.3 Ggplot2 3.4 Экспорт графиков из среды R", " Тема 3 Визуализации 3.1 Базовый R В R существуют три основные системы построения графиков, которые могут быть полезны для достижения разных целей. Базовый R – это самая старая система, и в ее основе лежит идея палитры художника2. Идея заключается в том, что у вас есть чистый холст, на который вы добавляете что-то одно за другим: например, сначала вы создаете диаграмму рассеяния с несколькими точками, затем вы добавляете метки, линию регрессии, заголовки и т.п. Каждая деталь графика занимает еще одну строчку кода. Это интуитивно понятная модель, потому что часто в самом начале, исследуя данные, мы часто не знаем, какой график мы хотим построить. Обычно мы начинаем это построение с функции plot(), а затем добавляем функции, которые аннотируют график. Вот простой пример на данных о гапаксах у Платона, которые мы видели раньше. Чтобы построить диаграмму рассеяния (scatter plot), нужно передать функции plot() в качестве аргументов названия тех столбцов, которые мы хотим изобразить по осям x и y. Это можно записать так: plot(x, y). Или так: plot(y ~ x). Знак ~ (тильда) указывает на функцию. attach(hapax_plato) plot(hapax ~ words) Это можно записать и иначе: plot(hapax_plato$hapax ~ hapax_plato$words). Результат будет одинаковый. Теперь беремся за палитру. Данные скучились в левом нижнем углу и потому плохо читаются. Мы можем пожертвовать двумя очень длинными диалогами (это “Государство” и “Законы”) и “приблизить” картинку, указав вручную границы осей. attach(hapax_plato) plot(hapax ~ words, xlim = c(0, 30000), ylim = c(0, 500)) Но так мы все-таки теряем какую-то информацию – а вдруг она важная? Еще один способ справиться со слипшимися данными – преобразовать их. Применим логарифмическое преобразование. Обратите внимание, как меняются значения на осях. attach(hapax_plato) options(scipen=999) # избавляет от научной нотации plot(words, hapax, log = &quot;xy&quot;) # добавим текст text(hapax ~ words, labels = dialogue, pos = 2, cex = 0.7) Уже гораздо интереснее! Попробуем обозначить цветом и формой пересказанные и прямые диалоги. Форма задается внутри функции plot() при помощи атрибута pch. Числовые значения этого атрибута соответствуют следующим значкам. Мы используем 2, 3 и 5. Добавить картинку: значения атрибута pch Перестраиваем наш график. attach(hapax_plato) options(scipen=999) # избавляет от научной нотации plot(words, hapax, log = &quot;xy&quot;, col = c(&quot;darkblue&quot;, &quot;darkgreen&quot;, &quot;darkred&quot;)[group], pch = c(2, 3, 5)[group]) text(hapax ~ words, labels = dialogue, pos = 2, cex = 0.7, col = c(&quot;darkblue&quot;, &quot;darkgreen&quot;, &quot;darkred&quot;)[group]) Некоторые названия перекрываютcя, но все равно намного понятнее. Теперь можем поменять шрифт и, например, добавить линию регрессии (не хватает легенды, но что-то уже нет сил). attach(hapax_plato) options(scipen=999) # избавляет от научной нотации plot(words, hapax, log = &quot;xy&quot;, col = c(&quot;darkblue&quot;, &quot;darkgreen&quot;, &quot;darkred&quot;)[group], pch = c(2, 3, 5)[group], family = &quot;serif&quot;) text(hapax ~ words, labels = dialogue, pos = 2, cex = 0.7, col = c(&quot;darkblue&quot;, &quot;darkgreen&quot;, &quot;darkred&quot;)[group], family = &quot;serif&quot;) # добавим линию регрессии my_lm &lt;- lm(hapax_plato$hapax ~ hapax_plato$words) abline(my_lm, lty = &quot;dashed&quot;, col = &quot;darkgrey&quot;, untf = T) # и заголовок title(main = &quot;Число гапаксов в зависимости от длины диалога&quot;) При помощи графических параметров3 можно контролировать множество настроек. Но в этом и недостаток базовой графики. Не всем хватает терпения и вкуса этим заниматься, поэтому эта система сейчас не очень употребительна. Мы построили только диаграмму рассеяния, но в базовом R можно делать и гистограммы, и диаграмму размаха, и другие графики. Попробуйте интерпретировать график, который у нас получился. Прав ли был профессор Кэмпбелл, утверждая, что высокая доля гапаксов характерна для “поздних” текстов? Исходите из того, что ни для одного текста мы не знаем дату написания. Судя по графику, количество гапаксов зависит от количества слов в тексте. Чем длиннее текст, тем больше вероятность встретить там редкое слово. 3.2 Lattice Система Lattice (букв. “Решетка”) была разработана специально для анализа многомерных данных (sarkar2008?). Тут должны быть графики цветочки Например, мы сравниваем точность классификации текстов в зависимости от длины отрывка и количества слов-предикторов. Это уже три переменные (длина – количество слов – точность). Система решеток, или панелей, позволяет представить такие многомерные данные. Добавить ссылку В базовом R это тоже можно сделать, изменив графические параметры: x &lt;- sample(1:20, 10) y &lt;- 2 * x - 5 par(mfrow = c(1,2)) # вот тут указываем число рядов и столбцов plot(x, y) plot(x, y) Но видно, что пространство при этом расходуется неэффективно. Кроме того, к таким графикам сложно создавать заголовки и подзаголовки, подбирать подписи и т.п. Все эти задачи решает Lattice. Идея этой системы в том, что каждый график строится с помощью одного вызова функции. При этом необходимо сразу указать большое количество информации, чтобы у фунцкии было достаточно данных для построения графика. library(lattice) attach(hapax_plato) # после вертикальной черты указана переменная, которая используется для группировки данных; в нашем случае номер группы (по Кэмпбеллу) xyplot(hapax ~ words | group, data = hapax_plato, scales=list(x=list(log=10))) # трансформация по одной оси Недостаток Lattice, однако, в том, что бывает сложно аннотировать отдельные панели, а также приходится сразу задавать весь график в одном вызове функции. Это не всегда удобно. После создания графика уже ничего нельзя добавить или убавить. 3.3 Ggplot2 Но настоящая графическая сила R – это пакет ggplot2. В его основе лежит идея “грамматики графических элементов” Лиланда Уилкинсона (мастицкий2017?), и он позволяет объединить достоинства базовой графики R и Lattice. С одной стороны, вы можете постепенно достраивать график, добавляя элемент за элементом; с другой стороны, множество параметров подбираются автоматически, как в Lattice. 3.3.1 Быстрое решение: qplot() Настройки по умолчанию хорошо видно на графике ниже; их легко перенастроить. library(ggplot2) # загружается сразу с tidyverse options(scipen = 999) qplot(words, hapax, data = hapax_plato, log = &quot;xy&quot;) ## Warning: `qplot()` was deprecated in ggplot2 3.4.0. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. Функция qplot() – это быстрое решение для задач визуализации. В современных версиях ggplot использование функции qplot() не рекомендуется (deprecated), чтобы побудить пользователей изучать ggplot() как более совершенный инструмент для визуализаций. В данном случае мы построили диаграмму рассеяния, используя логарифмическую трансформацию по двум осям. Можно также выделить цветом различные типы диалогов, изменить размер точек, их прозначность и т.п. qplot(words, hapax, data = hapax_plato, log = &quot;xy&quot;, col = group, size = 1.5) + theme(legend.position = &quot;none&quot;) Линия тренда (сглаживающая линия) добавляется следующим образом: qplot(words, hapax, data = hapax_plato, log = &quot;xy&quot;, geom = c(&quot;point&quot;, &quot;smooth&quot;)) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Диаграмма размаха (о ней подробнее можно посмотреть здесь) удобна в тех случаях, когда необходимо представить обобщенную статиситческую информацию о распределении значений количественной переменной в разных группах. attach(hapax_plato) qplot(group, ratio, data = hapax_plato, geom = &quot;boxplot&quot;, color = group) Диаграмму размаха можно совместить с одномерной диаграммой рассеяния. qplot(group, ratio, data = hapax_plato, geom = c(&quot;boxplot&quot;, &quot;jitter&quot;), color = group) # вместо color можно использовать shape, который отвечает за форму элементов 3.3.2 Слой за слоем: ggplot() Для более детальной настройки графика рекомендууется использовать функцию ggplot(), которая имеет два основных аргумента: data и aes (англ. aesthetics); последняя присваивает эстетические атрибуты геометрическим объектам, которые используются на графике. Эти объекты могут слоями накладываться друг на друга (wickham2016?). Посмотрим, как это работает, на примере, столбиковой диаграммы. Такая позволяет представить распределение как количественных, так и качественных переменных. Для примера возьмем датасет diorisis_meta, который хранит данные о древнегреческих текстах, доступных в репозитории Diorisis4. load(&quot;./datasets/DiorisisMeta.Rdata&quot;) diorisis_meta ## # A tibble: 784 × 5 ## name title date genre subgenre ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Achilles Tatius Leucippe and Clitophon 120 Narrative Novel ## 2 Aelian De Natura Animalium 230 Technical Natural History ## 3 Aelian Epistulae Rusticae 230 Letters Letters ## 4 Aelian Varia Historia 200 Essays Miscellanea ## 5 Aeneas Tacticus Poliorcetica -350 Technical Military ## 6 Aeschines Against Ctesiphon -330 Oratory Oratory ## 7 Aeschines Against Timarchus -347 Oratory Oratory ## 8 Aeschines The Speech on the Embassy -336 Oratory Oratory ## 9 Aeschylus Agamemnon -458 Tragedy Tragedy ## 10 Aeschylus Eumenides -458 Tragedy Tragedy ## # ℹ 774 more rows Столбиковая диаграмма позволяет увидеть, тексты каких жанров чаще всего встречаются в этом корпусе. library(tidyverse) diorisis_meta %&gt;% group_by(genre) %&gt;% count() %&gt;% ggplot(aes(reorder(genre, n), n, fill = genre)) + geom_bar(stat = &quot;identity&quot;) + coord_flip() Точечная диаграмма, или dotplot, подходит для тех случаев, когда мы исследуем распределение наблюдений для разных групп данных, причем наблюдений не очень много. Например, мы можем отразить распределение текстов в корпусе по годам. Категориальную переменную (например, жанр) можно дополнительно закодировать цветом (Подробнее). diorisis_meta %&gt;% ggplot(aes(date, fill = factor(genre))) + geom_dotplot(binwidth = 10, stackdir = &quot;centerwhole&quot;, binpositions = &quot;all&quot;) + scale_y_continuous(NULL, breaks = NULL) + scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) Различные группы данных можно выделять не только цветом и формой, но Категоризованный график – отдельный график для разных групп. Попробуем выяснить: сколько поджанров в каждом жанре? diorisis_meta %&gt;% group_by(genre, subgenre) %&gt;% count %&gt;% filter(genre %in% c(&quot;Poetry&quot;, &quot;Technical&quot;)) %&gt;% ggplot(aes(reorder(subgenre, n), n, fill = subgenre)) + geom_col(show.legend = F) + facet_wrap(~genre, scales = &quot;free&quot;) + # вот здесь задаем группы coord_flip() Подробнее с разными видами графиков мы познакомимся дальше. 3.4 Экспорт графиков из среды R Способы: реализованные в R драйверы стандартных графических устройств; функция ggsave() меню программы RStudio. # код сохранит pdf в рабочую директорию pdf(file = &quot;Diorisis.pdf&quot;) diorisis_meta %&gt;% group_by(genre, subgenre) %&gt;% count %&gt;% filter(genre %in% c(&quot;Poetry&quot;, &quot;Technical&quot;)) %&gt;% ggplot(aes(reorder(subgenre, n), n, fill = subgenre)) + geom_col(show.legend = F) + facet_wrap(~genre, scales = &quot;free&quot;) + coord_flip() dev.off() # еще один способ сохранить последний график ggsave( filename = &quot;Diorisis.png&quot;, plot = last_plot(), device = &quot;png&quot;, scale = 1, width = NA, height = 500, units = &quot;px&quot;, dpi = 300 ) https://youtu.be/a4mvbyNGdBA↩︎ https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/par↩︎ https://figshare.com/articles/dataset/The_Diorisis_Ancient_Greek_Corpus/6187256↩︎ "],["опрятные-данные.html", "Тема 4 Опрятные данные 4.1 Синтаксис tidyverse 4.2 Опрятные данные 4.3 Пример: буккроссинг", " Тема 4 Опрятные данные Tidy datasets are all alike, but every messy dataset is messy in its own way. — Hadley Wickham 4.1 Синтаксис tidyverse Существуют два основных “диалекта” R, один из которых опирается главным образом на функции и структуры данных базового R, а другой пользуется синтаксисом tidyverse (winter2020?). Tidyverse – это семейство пакетов (метапакет), разработанных Хадли Уикхемом и др., которое включает в себя в том числе пакеты dplyr, ggplot2 и многие другие. # загрузить все семейство library(tidyverse) 4.1.1 Tibble Основная структура данных в tidyverse – это tibble, современный вариант датафрейма5. Тиббл, как говорят его разработчики, это ленивые и недовольные датафреймы: они делают меньше и жалуются больше6. Это позволяет решать проблемы на более ранних этапах, что, как правило, приводит к созданию более чистого и выразительного кода. Основные отличия от обычного датафрейма: текст по умолчанию конвертируется в строки, а не в факторы;7 усовершенствованный метод print(), не нужно постоянно вызывать head(); нет имен рядов; допускает синтаксически “неправильные” имена столбцов; при индексировании не меняет тип данных на вектор и др. load(&quot;./datasets/DiorisisMeta.Rdata&quot;) # распечатывает только первые 10 рядов, для каждого столбца указан тип данных, строки пронумерованы as_tibble(diorisis_meta) ## # A tibble: 784 × 5 ## name title date genre subgenre ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Achilles Tatius Leucippe and Clitophon 120 Narrative Novel ## 2 Aelian De Natura Animalium 230 Technical Natural History ## 3 Aelian Epistulae Rusticae 230 Letters Letters ## 4 Aelian Varia Historia 200 Essays Miscellanea ## 5 Aeneas Tacticus Poliorcetica -350 Technical Military ## 6 Aeschines Against Ctesiphon -330 Oratory Oratory ## 7 Aeschines Against Timarchus -347 Oratory Oratory ## 8 Aeschines The Speech on the Embassy -336 Oratory Oratory ## 9 Aeschylus Agamemnon -458 Tragedy Tragedy ## 10 Aeschylus Eumenides -458 Tragedy Tragedy ## # ℹ 774 more rows # индексирование head(as.data.frame(diorisis_meta)[, 1]) # возвращает вектор ## [1] &quot;Achilles Tatius&quot; &quot;Aelian&quot; &quot;Aelian&quot; &quot;Aelian&quot; ## [5] &quot;Aeneas Tacticus&quot; &quot;Aeschines&quot; as_tibble(diorisis_meta)[,1] # возвращает тиббл ## # A tibble: 784 × 1 ## name ## &lt;chr&gt; ## 1 Achilles Tatius ## 2 Aelian ## 3 Aelian ## 4 Aelian ## 5 Aeneas Tacticus ## 6 Aeschines ## 7 Aeschines ## 8 Aeschines ## 9 Aeschylus ## 10 Aeschylus ## # ℹ 774 more rows # имена столбцов df &lt;- data.frame(&#39;var 1&#39; = 1:2, two = 3:4) df ## var.1 two ## 1 1 3 ## 2 2 4 tbl &lt;- tibble(&#39;var 1&#39; = 1:2, two = 3:4) tbl ## # A tibble: 2 × 2 ## `var 1` two ## &lt;int&gt; &lt;int&gt; ## 1 1 3 ## 2 2 4 4.1.2 Dplyr Но самое главное, tibble подходит для “грамматики манипуляции данных”, лежащей в основе dplyr8. Эта грамматика предоставляет последовательный набор глаголов, которые помогают решать наиболее распространенные задачи манипулирования данными: mutate() добавляет новые переменные, которые являются функциями существующих переменных; select() выбирает переменные на основе их имен; filter() выбирает наблюдения на основе их значений; summarise() обобщает значения; arrange() изменяет порядок следования строк. Все эти глаголы естественным образом сочетаются с функцией group_by(), которая позволяет выполнять любые операции “по группам”, и с оператором pipe %&gt;% из пакета magrittr. В итоге получается более лаконичный и читаемый код, что можно показать на примере. diorisis_meta %&gt;% select(-subgenre) %&gt;% filter(genre == &quot;Narrative&quot;) %&gt;% # не нужны кавычки! group_by(name) %&gt;% count() %&gt;% arrange(-n) ## # A tibble: 20 × 2 ## # Groups: name [20] ## name n ## &lt;chr&gt; &lt;int&gt; ## 1 Plutarch 71 ## 2 Appian 14 ## 3 Flavius Josephus 4 ## 4 Xenophon 4 ## 5 Arrian 3 ## 6 Diodorus Siculus 3 ## 7 Philostratus the Athenian 2 ## 8 Achilles Tatius 1 ## 9 Cassius Dio 1 ## 10 Chariton 1 ## 11 Diogenes Laertius 1 ## 12 Dionysius of Halicarnassus 1 ## 13 Eusebius of Caesarea 1 ## 14 Herodotus 1 ## 15 Longus 1 ## 16 Lucian 1 ## 17 Polybius 1 ## 18 Pseudo Apollodorus 1 ## 19 Thucydides 1 ## 20 Xenophon of Ephesus 1 В базовом R мы бы делали то же самое вот так: diorisis_df &lt;- as.data.frame(diorisis_meta) diorisis_select &lt;- diorisis_df[,-5] # remove column diorisis_filter &lt;- diorisis_select[diorisis_select$genre == &quot;Narrative&quot;, ] diorisis_names &lt;- diorisis_filter$name diorisis_count &lt;- as.data.frame(table(diorisis_names)) diorisis_sort &lt;- diorisis_count[order(diorisis_count$Freq, decreasing =T),] diorisis_sort ## diorisis_names Freq ## 15 Plutarch 71 ## 2 Appian 14 ## 10 Flavius Josephus 4 ## 19 Xenophon 4 ## 3 Arrian 3 ## 6 Diodorus Siculus 3 ## 14 Philostratus the Athenian 2 ## 1 Achilles Tatius 1 ## 4 Cassius Dio 1 ## 5 Chariton 1 ## 7 Diogenes Laertius 1 ## 8 Dionysius of Halicarnassus 1 ## 9 Eusebius of Caesarea 1 ## 11 Herodotus 1 ## 12 Longus 1 ## 13 Lucian 1 ## 16 Polybius 1 ## 17 Pseudo Apollodorus 1 ## 18 Thucydides 1 ## 20 Xenophon of Ephesus 1 Тут должен быть какой-то поучительный вывод. 4.2 Опрятные данные Но tidyverse – это не только особый синтаксис, но и отдельная идеология “опрятных данных”. “Сырые” данные, с которыми мы работаем, редко бывают опрятны, и перед анализом их следует “почистить” и преобразовать9. Основные правила опрятных данных: отдельный столбец для каждой переменной; отдельный ряд для каждого наблюдения; у каждого значения отдельная ячейка; один датасет – одна таблица. Добавить картинку: принципы опрятных данных. Посмотрите на эти данные из пакета tidyr и подумайте, какое из этих правил нарушено в каждом случае. data(&quot;table2&quot;) table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 data(&quot;table3&quot;) table3 ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 data(&quot;table4a&quot;) table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 data(&quot;table4b&quot;) table4b ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 Важные функции для преобразования данных из пакета tidyr:10 separate() делит один столбец на новые; unite() объединяет столбцы; pivot_longer() удлиняет таблицу; pivot_wider() расширяет таблицу; drop_na() и replace_na() указывают, что делать с NA и др. Также упомянем функцию distinct() из dplyr, которая оставляет только уникальные наблюдения и предсталяет собой аналог базовой unique() для таблиц. Кроме того, в dplyr есть полезное семейство функций _join, позволяющих объединять данные в различных таблицах.11 Ниже мы потренируемся с ними работать. 4.3 Пример: буккроссинг 4.3.1 Смотрим на данные Загрузим пример неопрятных данных и попробуем их преобразовать для анализа. Book-Crossing – датасет с рейтингами миллионов книг и обезличенными демографическими данными о более 250 тысячах их читателей. Этот датасет хранится в трех разных таблицах. load(&quot;./datasets/BooksBX.Rdata&quot;) load(&quot;./datasets/RatingsBX.Rdata&quot;) load(&quot;./datasets/UsersBX.Rdata&quot;) ratings ## # A tibble: 493,813 × 3 ## `User-ID` ISBN `Book-Rating` ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 276725 034545104X 0 ## 2 276726 0155061224 5 ## 3 276727 0446520802 0 ## 4 276729 052165615X 3 ## 5 276729 0521795028 6 ## 6 276733 2080674722 0 ## 7 276736 3257224281 8 ## 8 276737 0600570967 6 ## 9 276744 038550120X 7 ## 10 276745 342310538 10 ## # ℹ 493,803 more rows users ## # A tibble: 246,666 × 3 ## `User-ID` Location Age ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 nyc, new york, usa NULL ## 2 2 stockton, california, usa 18 ## 3 3 moscow, yukon territory, russia NULL ## 4 4 porto, v.n.gaia, portugal 17 ## 5 5 farnborough, hants, united kingdom NULL ## 6 6 santa monica, california, usa 61 ## 7 7 washington, dc, usa NULL ## 8 8 timmins, ontario, canada NULL ## 9 9 germantown, tennessee, usa NULL ## 10 10 albacete, wisconsin, spain 26 ## # ℹ 246,656 more rows books ## # A tibble: 270,760 × 8 ## ISBN `Book-Title` `Book-Author` `Year-Of-Publication` Publisher ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 0195153448 Classical Mythology Mark P. O. M… 2002 Oxford U… ## 2 0002005018 Clara Callan Richard Bruc… 2001 HarperFl… ## 3 0060973129 Decision in Normandy Carlo D&#39;Este 1991 HarperPe… ## 4 0374157065 Flu: The Story of t… Gina Bari Ko… 1999 Farrar S… ## 5 0393045218 The Mummies of Urum… E. J. W. Bar… 1999 W. W. No… ## 6 0399135782 The Kitchen God&#39;s W… Amy Tan 1991 Putnam P… ## 7 0425176428 What If?: The World… Robert Cowley 2000 Berkley … ## 8 0671870432 PLEADING GUILTY Scott Turow 1993 Audiowor… ## 9 0679425608 Under the Black Fla… David Cordin… 1996 Random H… ## 10 074322678X Where You&#39;ll Find M… Ann Beattie 2002 Scribner ## # ℹ 270,750 more rows ## # ℹ 3 more variables: `Image-URL-S` &lt;chr&gt;, `Image-URL-M` &lt;chr&gt;, ## # `Image-URL-L` &lt;chr&gt; Что не так с этими данными? users содержит больше одного значения в столбце Location много отсутствующих значений данные вводятся самими пользователями через сайт https://www.bookcrossing.com/ ; они могут содержать недостоверную информацию, см. напр. moscow, yukon territory, russia (Юкон – это территория Канады). Age представляет собой строку и др. Прежде чем начинать преобразование, надо сформулировать примерный вопрос и понять, что для нас важно, а что нет. Например: - Сколько читателей старше 30 лет пользуются сервисом в Австралии? - В какие года опубликованы самые популярные книги? - Кто популярнее у читателей, Роулинг или Толкин? - Какой процент пользователей никогда не оставляет отзывы? - Есть ли связь между возрастом и количеством оценок? и т.п. Также надо понять, через какие переменные связаны эти таблицы. Ответ: ratings и books связаны через переменную isbn, ratings и users связаны через переменную User-ID. 4.3.2 Трансформируем данные Начнем с пользователей. users_separated &lt;- users %&gt;% mutate(Age = as.numeric(Age)) %&gt;% filter(!is.na(Age)) %&gt;% # drop_na(Age) тоже решил бы нашу задачу separate(Location, into = c(NA, NA, &quot;country&quot;), sep = &quot;,&quot;) users_separated # можно было бы не сохранять, но так нагляднее ## # A tibble: 148,869 × 3 ## `User-ID` country Age ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 &quot; usa&quot; 18 ## 2 4 &quot; portugal&quot; 17 ## 3 6 &quot; usa&quot; 61 ## 4 10 &quot; spain&quot; 26 ## 5 11 &quot; australia&quot; 14 ## 6 13 &quot; spain&quot; 26 ## 7 18 &quot; brazil&quot; 25 ## 8 19 &quot;&quot; 14 ## 9 20 &quot; usa&quot; 19 ## 10 21 &quot; spain&quot; 46 ## # ℹ 148,859 more rows Здесь можно сразу посмотреть, из каких стран и какого возраста пользователи. users_separated %&gt;% group_by(country) %&gt;% count() %&gt;% arrange(-n) ## # A tibble: 543 × 2 ## # Groups: country [543] ## country n ## &lt;chr&gt; &lt;int&gt; ## 1 &quot; usa&quot; 67138 ## 2 &quot; united kingdom&quot; 10935 ## 3 &quot; canada&quot; 9877 ## 4 &quot; spain&quot; 9505 ## 5 &quot; germany&quot; 8016 ## 6 &quot; australia&quot; 7824 ## 7 &lt;NA&gt; 5914 ## 8 &quot; italy&quot; 4754 ## 9 &quot; france&quot; 2395 ## 10 &quot; portugal&quot; 2175 ## # ℹ 533 more rows Последние ряды этого тибла выглядят достаточно причудливо: users_separated %&gt;% group_by(country) %&gt;% count() %&gt;% arrange(n) ## # A tibble: 543 × 2 ## # Groups: country [543] ## country n ## &lt;chr&gt; &lt;int&gt; ## 1 &quot; pasig city.&quot; 1 ## 2 &quot; &amp;#20013;&amp;#22269;&quot; 1 ## 3 &quot; &amp;#32654;&amp;#22269;&quot; 1 ## 4 &quot; 5057chadwick ct.&quot; 1 ## 5 &quot; 600 083&quot; 1 ## 6 &quot; \\\\n/a\\\\\\&quot;&quot; 1 ## 7 &quot; a new year is ahead&quot; 1 ## 8 &quot; aberdeenshire&quot; 1 ## 9 &quot; agusan del sur&quot; 1 ## 10 &quot; alabama&quot; 1 ## # ℹ 533 more rows Здесь возможно несколько стратегий. Можно выбрать все ряды с названиями реальных стран либо (если это соответствует исследовательской задаче) какую-то одну страну. Можно и проигнорировать, если происхождение пользователей не так важно. Допустим, мы решаем сосредоточиться на Испании. Обратите внимание, что в название страны после разделения функцией separate() попали пробелы, и от них надо избавиться. Это делается при помощи регулярных выражений (о них в другой раз) и функции mutate(). spain_data &lt;- users_separated %&gt;% mutate(country = str_replace_all(country, pattern = &quot;\\\\s+&quot;, &quot;&quot;)) %&gt;% # это означает, что пробел мы меняем на &quot;ничто&quot;, т.е. убираем filter(country == &quot;spain&quot;) %&gt;% group_by(Age) %&gt;% count() %&gt;% arrange(-n) spain_data ## # A tibble: 86 × 2 ## # Groups: Age [86] ## Age n ## &lt;dbl&gt; &lt;int&gt; ## 1 25 514 ## 2 26 510 ## 3 23 480 ## 4 24 467 ## 5 28 459 ## 6 27 450 ## 7 29 430 ## 8 30 403 ## 9 22 386 ## 10 21 351 ## # ℹ 76 more rows Столбиковая диаграмма подходит для визуализации подобных данных: spain_data %&gt;% ggplot(aes(Age, n)) + geom_bar(stat = &quot;identity&quot;, col = &quot;blue&quot;, fill = &quot;white&quot;) + theme_bw() Какие целеустремленные испанцы! Читают от 0 до 183 лет 😵 После того, как мы убрали лишние пробелы из названий стран, можно фильтровать: spain_id &lt;- users_separated %&gt;% mutate(country = str_replace_all(country, pattern = &quot;\\\\s+&quot;, &quot;&quot;)) %&gt;% filter(country == &quot;spain&quot;) # на этот раз мы не считаем число наблюдений в группе, а забираем все ряды, которые отвечают условию 4.3.3 Объединяем данные Мы уже выяснили, что ratings и users связаны через переменную User-ID, и в ratings хотели бы оставить только те id, которые отвечают заданному условию (страна, возраст и т.п.). Для такого рода объединений как раз подходят функции _join12. Добавить картинку на джойны. spain_ratings &lt;- spain_id %&gt;% left_join(ratings) %&gt;% filter(!is.na(ISBN)) %&gt;% filter(`Book-Rating` &gt; 7) %&gt;% # имена синтаксически неправильные, поэтому требуется знак &quot;`&quot; group_by(ISBN) %&gt;% count() %&gt;% arrange(-n) ## Joining with `by = join_by(`User-ID`)` spain_ratings ## # A tibble: 1,281 × 2 ## # Groups: ISBN [1,281] ## ISBN n ## &lt;chr&gt; &lt;int&gt; ## 1 8432206407 4 ## 2 8433969978 4 ## 3 846630679X 4 ## 4 8472236552 4 ## 5 8495501198 4 ## 6 840149186X 3 ## 7 8401499585 3 ## 8 8423310353 3 ## 9 8423662152 3 ## 10 8432215007 3 ## # ℹ 1,271 more rows Осталось выяснить, что это за книги. Для этого объединяем spain_ratings и books. spain_books &lt;- spain_ratings %&gt;% filter(n &gt; 2) %&gt;% left_join(books) %&gt;% filter(!is.na(`Book-Title`), !is.na(`Book-Author`)) %&gt;% ungroup() ## Joining with `by = join_by(ISBN)` spain_books ## # A tibble: 15 × 9 ## ISBN n `Book-Title` `Book-Author` `Year-Of-Publication` Publisher ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 8432206407 4 Sin Noticias … Eduardo Mend… 1995 Planeta … ## 2 8433969978 4 El Libro de L… Paul Auster 2003 Anagrama ## 3 846630679X 4 La caverna = … Jose Saramago 2002 Punto de… ## 4 8472236552 4 UN Viejo Que … Luis Sepulve… 1993 Tusquets… ## 5 8495501198 4 Memorias de u… Arthur Golden 2001 Suma de … ## 6 840149186X 3 El Club de Lo… N. H. Kleinb… 1995 Plaza &amp;a… ## 7 8401499585 3 Los Pilares d… Ken Follett 1995 Plaza &amp;a… ## 8 8423310353 3 El Camino (Co… Miguel Delib… 1991 Continen… ## 9 8432215007 3 El perfume Patrick Susk… 1997 Editoria… ## 10 8445071408 3 El Senor De L… J. R. R. Tol… 2001 Minotauro ## 11 8445071416 3 El Hobbit J. R. R. Tol… 1991 Minotauro ## 12 8477204055 3 El caballero … Robert Fisher 2000 Obelisco ## 13 8478884459 3 Harry Potter … J. K. Rowling 1999 Lectorum… ## 14 8484602508 3 Diario de Un … Antonio Salas 2003 Temas de… ## 15 8495501112 3 Son De Mar Manuel Vicent 2002 Suma de … ## # ℹ 3 more variables: `Image-URL-S` &lt;chr&gt;, `Image-URL-M` &lt;chr&gt;, ## # `Image-URL-L` &lt;chr&gt; Как минимум мы выяснили, что испанцы предпочитают читать по испански! (Здесь снова можно подумать. Возможно, у одной книги разные ISBN, и стоило группировать не по ISBN, а по названию или автору?) Осталось избавиться от неинформативных столбцов (это ссылки, часто битые, на изображения обложки). Если мы знаем номера этих столбцов, то это можно сделать по индексу: spain_books %&gt;% select(3:5) %&gt;% rename(title = `Book-Title`, author = `Book-Author`) ## # A tibble: 15 × 3 ## title author `Year-Of-Publication` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Sin Noticias De Gurb (Biblioteca breve) Eduar… 1995 ## 2 El Libro de Las Ilusiones Paul … 2003 ## 3 La caverna = A caverna Jose … 2002 ## 4 UN Viejo Que Leia Novelas De Amor/the Old Men W… Luis … 1993 ## 5 Memorias de una geisha Arthu… 2001 ## 6 El Club de Los Poetas Muertos N. H.… 1995 ## 7 Los Pilares de La Tierra Ken F… 1995 ## 8 El Camino (Coleccion Destinolibro) Migue… 1991 ## 9 El perfume Patri… 1997 ## 10 El Senor De Los Anillos: LA Comunidad Del Anill… J. R.… 2001 ## 11 El Hobbit J. R.… 1991 ## 12 El caballero de la armadura oxidada Rober… 2000 ## 13 Harry Potter y la piedra filosofal J. K.… 1999 ## 14 Diario de Un Skin: Un Topo En El Movimiento Neo… Anton… 2003 ## 15 Son De Mar Manue… 2002 Однако у select() есть функции-помощники13, которые подходят для таких случаев: starts_with() ends_with() contains() matches() num_range() spain_books %&gt;% select(-contains(&quot;URL&quot;), -matches(&quot;Publisher&quot;)) %&gt;% # удалим заодно и издателя rename(title = `Book-Title`, author = `Book-Author`, published = `Year-Of-Publication`) # чиним имена ## # A tibble: 15 × 5 ## ISBN n title author published ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 8432206407 4 Sin Noticias De Gurb (Biblioteca breve) Eduar… 1995 ## 2 8433969978 4 El Libro de Las Ilusiones Paul … 2003 ## 3 846630679X 4 La caverna = A caverna Jose … 2002 ## 4 8472236552 4 UN Viejo Que Leia Novelas De Amor/the Old … Luis … 1993 ## 5 8495501198 4 Memorias de una geisha Arthu… 2001 ## 6 840149186X 3 El Club de Los Poetas Muertos N. H.… 1995 ## 7 8401499585 3 Los Pilares de La Tierra Ken F… 1995 ## 8 8423310353 3 El Camino (Coleccion Destinolibro) Migue… 1991 ## 9 8432215007 3 El perfume Patri… 1997 ## 10 8445071408 3 El Senor De Los Anillos: LA Comunidad Del … J. R.… 2001 ## 11 8445071416 3 El Hobbit J. R.… 1991 ## 12 8477204055 3 El caballero de la armadura oxidada Rober… 2000 ## 13 8478884459 3 Harry Potter y la piedra filosofal J. K.… 1999 ## 14 8484602508 3 Diario de Un Skin: Un Topo En El Movimient… Anton… 2003 ## 15 8495501112 3 Son De Mar Manue… 2002 Возможно, сюда стоит добавить что-то про работу с факторами. https://r4ds.had.co.nz/tibbles.html↩︎ https://tibble.tidyverse.org/↩︎ Подробнее о том, почему так вообще происходит: https://simplystatistics.org/posts/2015-07-24-stringsasfactors-an-unauthorized-biography/↩︎ https://dplyr.tidyverse.org/↩︎ https://r4ds.had.co.nz/tidy-data.html↩︎ https://tidyr.tidyverse.org/reference/index.html↩︎ https://r4ds.had.co.nz/relational-data.html↩︎ https://r4ds.had.co.nz/relational-data.html↩︎ https://r4ds.had.co.nz/transform.html↩︎ "],["функциональное-программирование.html", "Тема 5 Функциональное программирование 5.1 Написание функций 5.2 Векторизируй это 5.3 Зачем писать функции? 5.4 Векторизованные конструкции 5.5 Семейство функций _apply из базового R 5.6 Purrr 5.7 Furrr", " Тема 5 Функциональное программирование 5.1 Написание функций Суть программирования на R сводится к написанию функций. Функция представляет собой набор команд, которые получают входные данные, используют их для вычисления других значений и возвращают результат (мэтлофф2019?). Чтобы определить функцию, необходимо дать ей имя, определить формальные аргументы и, при желании, значения по умолчанию. Тело функции пишется в фигурных скобках. В конце кода функции располагается команда return(); если ее нет, то функция возвращает последнее вычисленное значение (см. здесь о том, когда что предпочесть). Напишем функцию, которая будет центрировать данные, то есть вычитать среднее из каждого значения: center &lt;- function(x){ n = x - mean(x) return(n) } x &lt;- c(5, 10, 15) center(x) # это уже не формальный, а фактический аргумент ## [1] -5 0 5 То же делает встроенная функция scale() (если значение аргумента scale = F; в противном случае разность дополнительно делится на стандартное отклонение, это называется стандартизация). Внутри нашей функции есть переменная n, которую не видно в глобальном окружении. Это локальная переменная. Область ее видимости – тело функции. Когда функция возвращает управление, переменная исчезает. Обратное неверно: глобальные переменные доступны в теле функции. Функция может принимать произвольное число аргументов. Доработаем наш код: center &lt;- function(x, na.rm = F){ if(na.rm) { x &lt;- x[!is.na(x)]} # добавим условие x - mean(x) # на этот раз без return() } x &lt;- c(5, 10, NA) center(x) ## [1] NA NA NA Что произошло? Почему следующий код выдает другой результат? center(x, na.rm = T) ## [1] -2.5 2.5 Вычисления в R ленивы, то есть они откладываются до тех пор, пока не понадобится результат. Если вы зададите аргумент, который не нужен в теле функции, ошибки не будет. center &lt;- function(x, na.rm = F, what_is_your_name){ if(na.rm) { x &lt;- x[!is.na(x)]} # добавим условие x - mean(x) # на этот раз без return() } center(x, na.rm = T) ## [1] -2.5 2.5 center(x, na.rm = T, what_is_your_name = &quot;Locusclassicus&quot;) ## [1] -2.5 2.5 Машине все равно, как вы назовете функцию, но тем, кто будет читать код, не все равно. Имена должны быть информативы (поэтому функция f() – плохая идея). Также не стоит переписывать уже существующие в R имена! Часто имеет смысл добавить условие остановки или сообщение, которое будет распечатано в консоль при выполнении. center &lt;- function(x){ if (length(x) == 1) {stop(&quot;И без меня посчитает&quot;)} x - mean(x) # на этот раз без return() } x &lt;- 10 center(x) # вернет ошибку Впрочем, в таких простых функциях в R нет необходимости. Сравните: x &lt;- c(5, 10, 15) x - mean(x) ## [1] -5 0 5 5.2 Векторизируй это Если имеется функция f(), которая должна быть применена ко всем элементам вектора x, то во многих случаях задача решается простым вызовом f() для самого вектора x. Это и есть векторизация. Она упрощает код и улучшает быстродействие. Если функция R использует векторизованные операции, то она тоже является векторизованной (мэтлофф2019?). Это относится не только ко многим встроенным функциям R, но и к даже к операторам. x + 4 в действительности представляет собой +(x, 4): x &lt;- c(1.2, 2.51, 3.8) # пример со встроенной функцией round(x) ## [1] 1 3 4 # пример с оператором `+`(x, 4) ## [1] 5.20 6.51 7.80 Ключевую роль здесь играет переработка данных, о которой мы уже говорили: короткий вектор повторяется до тех пор, пока его длина не сравняется с длиной более длинного вектора. is_article &lt;- function(x){ x == c(&quot;a&quot;, &quot;the&quot;) } x &lt;- &quot;the&quot; is_article(x) # возвращает два значения, хотя на входе было одно ## [1] FALSE TRUE В двух примерах ниже векторы равной длины, но тут тоже есть особенность. x &lt;- c(&quot;just&quot;, &quot;the&quot;) is_article(x) ## [1] FALSE TRUE x &lt;- c(&quot;the&quot;, &quot;just&quot;) is_article(x) # взрыв мозга ## [1] FALSE FALSE Почему так? Внутри нашей функции вектор, а два вектора сравниваются поэлементно! Получается, что для сравнения списка слов со списком артиклей нам надо переписать функцию. Например, так: is_article &lt;- function(x) { articles &lt;- c(&quot;a&quot;, &quot;the&quot;) x %in% articles } x &lt;- c(rep(&quot;the&quot;, 5), rep(&quot;if&quot;, 5)) is_article(x) ## [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE sum(is_article(x)) ## [1] 5 5.3 Зачем писать функции? Функции имеют три преимущества перед простой копипастой: у функции есть выразительное имя, которое облегчает понимание кода; при изменении требований необходимо обновлять код только в одном месте, а не во многих; меньше вероятность случайных ошибок при копировании (например, обновление имени переменной в одном месте, но не в другом)подробнее Запомните простое правило: если вы трижды скопировали код, пора писать функцию! Writing good functions is a lifetime journey. — Hadley Wickham Это не так сложно. Сначала пишем обычный код, потом превращаем его в функцию. Например, нам нужна функция, которая ищет совпадения в двух векторах и возвращает совпавшие элементы. # сначала решаем задачу для двух векторов x &lt;- c(&quot;гнев&quot;, &quot;богиня&quot;, &quot;воспой&quot;) y &lt;- c(&quot;в&quot;, &quot;мысли&quot;, &quot;ему&quot;, &quot;то&quot;, &quot;вложила&quot;, &quot;богиня&quot;, &quot;державная&quot;, &quot;гера&quot;) idx &lt;- which(x %in% y) x[idx] ## [1] &quot;богиня&quot; # потом упаковываем в функцию common_words &lt;- function(x, y){ idx &lt;- which(x %in% y) x[idx] } # применяем к новым данным x &lt;- c(&quot;лишь&quot;, &quot;явилась&quot;, &quot;заря&quot;, &quot;розоперстая&quot;, &quot;вестница&quot;, &quot;утра&quot;) y &lt;- c(&quot;вестница&quot;, &quot;утра&quot;, &quot;заря&quot;, &quot;на&quot;, &quot;великий&quot;, &quot;олимп&quot;, &quot;восходила&quot;) common_words(x, y) ## [1] &quot;заря&quot; &quot;вестница&quot; &quot;утра&quot; И ура, все работает! Кроме того, очень полезно читать чужой код (если он хорошо написан). Начинку функции можно распечатать в консоль, если ввести ее название без скобок. Ниже код функции из пакета Stylo; эта функция отвечает за вычисление знаменитой Delta Берроуза. Попробуйте понять, что она делает. library(stylo) dist.delta ## function (x, scale = TRUE) ## { ## if (is.matrix(x) == FALSE &amp; is.data.frame(x) == FALSE) { ## stop(&quot;cannot apply a distance measure: wrong data format!&quot;) ## } ## if (length(x[1, ]) &lt; 2 | length(x[, 1]) &lt; 2) { ## stop(&quot;at least 2 cols and 2 rows are needed to compute a distance!&quot;) ## } ## if (scale == TRUE) { ## x = scale(x) ## } ## y = dist(x, method = &quot;manhattan&quot;)/length(x[1, ]) ## return(y) ## } ## &lt;bytecode: 0x14fbe77c0&gt; ## &lt;environment: namespace:stylo&gt; 5.4 Векторизованные конструкции 5.4.1 Циклы Еще один способ повторить действия в R, при этом не копируя один и тот же код много раз, – это циклы. Один из главных принципов программирования на R гласит, что следует обходиться без циклов, а если это невозможно, то циклы должны быть простыми. — Нормат Мэтлофф Существует два основных цикла: цикл for и цикл while. На практике чаще используется цикл for, потому что цикл while легко отправить в бесконечность. 5.4.1.1 Цикл for Цикл ниже считает количество букв для каждого слова в векторе. y &lt;- c(&quot;в&quot;, &quot;мысли&quot;, &quot;ему&quot;, &quot;то&quot;, &quot;вложила&quot;, &quot;богиня&quot;, &quot;державная&quot;, &quot;гера&quot;) result &lt;- c() for(i in y) { n &lt;- nchar(i) result &lt;- c(result, n) } result ## [1] 1 5 3 2 7 6 9 4 В данном случае мы указали, что надо совершить какую-то операцию над каждым элементом вектора; но по сути это избыточно, потому что nchar() тоже векторизована. nchar(y) ## [1] 1 5 3 2 7 6 9 4 Поэтому чаще цикл for применяют к другим структурам данных. Например, к спискам и датафреймам (хотя и этого можно избежать, о чем будет сказано дальше). Загрузим и немного изменим датасет о гапаксах у Платона. Изменения нужны, так как цикл работает для данных только одного вида. rownames(hapax_plato) &lt;- hapax_plato$dialogue hapax_plato &lt;- hapax_plato %&gt;% select(-ratio, -group, -dialogue) # оператор pipe и функции из dplyr работают и с обычными датафреймами! str(hapax_plato) ## &#39;data.frame&#39;: 26 obs. of 2 variables: ## $ words: chr &quot;8745&quot; &quot;8311&quot; &quot;17944&quot; &quot;4950&quot; ... ## $ hapax: chr &quot;36&quot; &quot;31&quot; &quot;122&quot; &quot;104&quot; ... Сейчас данные в нашей таблице имеют тип chr, то есть строка, и при помощи цикла мы можем их трансформировать. for (i in seq_along(hapax_plato)) { # seq_along ≈ 1:length(x) hapax_plato[,i] &lt;- as.numeric(hapax_plato[,i]) } str(hapax_plato) # убеждаемся, что все получилось ## &#39;data.frame&#39;: 26 obs. of 2 variables: ## $ words: num 8745 8311 17944 4950 4169 ... ## $ hapax: num 36 31 122 104 19 87 15 125 12 32 ... При помощи циклов можно не только трансформировать данные, но и создавать новые. Чтобы посчитать среднее для столбца, цикл писать не надо: для этого есть функция colSums() (или, для других задач, rowSums()). А вот посчитать медиану таким образом не получится, тут может пригодиться цикл. medians &lt;- c() for (i in seq_along(hapax_plato)) { m &lt;- median(hapax_plato[,i]) medians &lt;- c(medians, m) } medians ## [1] 15589.5 94.5 Мы сохранили результат, инициировав пустой вектор, к которому затем привязали данные по каждому столбцу. Это не всегда хорошая идея, поскольку для больших данных может сильно замедлить цикл14. Еще один способ – сразу инициировать вектор нужной длины. medians &lt;- vector(&quot;double&quot;, ncol(hapax_plato)) for (i in seq_along(hapax_plato)) { medians[i] &lt;- median(hapax_plato[,i]) } medians ## [1] 15589.5 94.5 Сравнить скорость можно при помощи пакета tictoc. library(tictoc) # способ первый tic() medians &lt;- c() for (i in seq_along(hapax_plato)) { m &lt;- median(hapax_plato[,i]) medians &lt;- c(medians, m) } toc() ## 0.003 sec elapsed # способ второй tic() medians &lt;- vector(&quot;double&quot;, ncol(hapax_plato)) for (i in seq_along(hapax_plato)) { medians[i] &lt;- median(hapax_plato[,i]) } toc() ## 0.003 sec elapsed Второй способ чуть быстрее, и для больших данных это может быть существенно (знала бы я это раньше). Вы уже заметили, что в циклах часто используется буква i. Но никакой особой магии в ней нет! 5.4.1.2 Цикл while Как уже говорилось, с циклами while стоит быть осторожнее. Посмотрите, например, на этот цикл, который перебирает слова, пока не найдет слово длиной 6 букв. Что могло пойти не так? k &lt;- 0 n &lt;- 0 while (n != 6) { k &lt;- k + 1 n &lt;- nchar(y[k]) } y[k] ## [1] &quot;богиня&quot; То же самое можно сделать без цикла. Если подходящего значения не найдется, нам вернется NA. y[nchar(y) == 6][1] ## [1] &quot;богиня&quot; 5.4.2 Условия Задействуются в тех случаях, когда выполнение функции ограничивается неким условием. if(any(nchar(y) &gt; 6)) print(&quot;многабукв&quot;) ## [1] &quot;многабукв&quot; Внутри условия не надо использовать логические операторы | (“или”) или &amp; (“и”), потому что они векторизованы: y ## [1] &quot;в&quot; &quot;мысли&quot; &quot;ему&quot; &quot;то&quot; &quot;вложила&quot; &quot;богиня&quot; ## [7] &quot;державная&quot; &quot;гера&quot; nchar(y) &gt; 6 | nchar(y) &lt; 2 ## [1] TRUE FALSE FALSE FALSE TRUE FALSE TRUE FALSE Вместо этого можно применять || (“или”) или &amp;&amp; (“и”), которые остановятся, дойдя до первого истинного значения. nchar(y) &gt; 6 || nchar(y) &lt; 2 ## [1] TRUE Множественные условия задаются так: if (sum(nchar(y)) &gt; 10) { print(&quot;много букв&quot;) } else if (sum(nchar(y)) &lt; 5) { print(&quot;мало букв&quot;) } else { print(&quot;норм букв&quot;) } ## [1] &quot;много букв&quot; Но можно и короче: ifelse((sum(nchar(y)) &gt; 10), &quot;много букв&quot;, &quot;мало букв&quot;) ## [1] &quot;много букв&quot; 5.5 Семейство функций _apply из базового R Как уже было сказано, лучше обойтись без циклов, для этого в базовом R есть семейство функций _apply. 5.5.1 tapply() Принимает на входе вектор, фактор (или список факторов) и функцию. Каждый фактор должен быть той же длины, что и вектор. load(&quot;./datasets/HapaxPlato.Rdata&quot;) my_fct &lt;- as.factor(hapax_plato$group) my_vct &lt;- as.numeric(hapax_plato$ratio) tapply(my_vct, my_fct, mean) ## 1 2 3 ## 0.00550000 0.00750000 0.01133333 На диалекте tidyverse эта задача решается так: hapax_plato %&gt;% mutate(ratio = as.numeric(ratio)) %&gt;% group_by(group) %&gt;% summarise(mean = mean(ratio)) ## # A tibble: 3 × 2 ## group mean ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0.0055 ## 2 2 0.0075 ## 3 3 0.0113 5.5.2 apply() Вызывает функцию для каждой строки или столбца матрицы или датафрейма. # переносим названия диалогов в названия рядов rownames(hapax_plato) &lt;- hapax_plato$dialogue hapax_plato &lt;- subset(hapax_plato, select = -c(dialogue, group)) # еще один способ убрать столбцы # уточним вид данных по столбцам str(hapax_plato) ## &#39;data.frame&#39;: 26 obs. of 3 variables: ## $ words: chr &quot;8745&quot; &quot;8311&quot; &quot;17944&quot; &quot;4950&quot; ... ## $ hapax: chr &quot;36&quot; &quot;31&quot; &quot;122&quot; &quot;104&quot; ... ## $ ratio: chr &quot;0.004&quot; &quot;0.004&quot; &quot;0.007&quot; &quot;0.021&quot; ... # преобразуем столбцы в числовой формат hapax_plato&lt;- apply(hapax_plato, 2, as.numeric) # и посчитаем стандартное отклонение по столбцам round((apply(hapax_plato, 2, sd)), 3) ## words hapax ratio ## 23640.597 208.856 0.004 В данном случае мы передали apply() функцию sd() из основного пакета stats, но можно написать свою (в том числе анонимную). hapax_centered &lt;- apply(hapax_plato, 2, function(x) x - mean(x)) head(hapax_centered) ## words hapax ratio ## [1,] -10619.423 -110.69231 -0.0031538462 ## [2,] -11053.423 -115.69231 -0.0031538462 ## [3,] -1420.423 -24.69231 -0.0001538462 ## [4,] -14414.423 -42.69231 0.0138461538 ## [5,] -15195.423 -127.69231 -0.0021538462 ## [6,] -6911.423 -59.69231 -0.0001538462 Опять-таки, все это решается (даже проще) в грамматике dplyr: as_tibble(hapax_plato) %&gt;% mutate(words = words - mean(words), hapax = hapax - mean(hapax), ratio = ratio - mean(ratio)) Но мы повторили один код три раза! Значит, это надо упростить! Например, так15: as_tibble(hapax_plato) %&gt;% mutate_all(function(x) x - mean(x)) Или даже так16: fn &lt;- function(x) x - mean(x) as_tibble(hapax_plato) %&gt;% mutate(across(1:3, fn)) В любом случае, нам удалось обойтись без цикла, код понятен и хорошо читается. 5.5.3 lapply() и sapply() Функции lapply() и sapply() подходят для применения функций к спискам. Чтобы понять, как они работают, сначала загрузим список. Списки, с которыми при анализе текста приходится иметь дело достаточно часто, – это объекты типа stylo.corpus, которые создает пакет stylo17. Загрузим корпус диалогов Платона. load(&quot;./datasets/PlatoStylo.Rdata&quot;) class(corpus) ## [1] &quot;stylo.corpus&quot; Если вы работаете в RStudio, то, нажав на объект corpus в окружении, вы увидите нечто такое (конечно, детали зависят от того, какие тексты у вас лежат в указанной директории): Добавить картинку Превью корпуса Здесь хорошо видно, что весь корпус – это список из 26 элементов (диалогов), а каждый диалог – символьный вектор. Проверим, используя индексирование списка, о котором шла речь выше: class(corpus[[1]]) ## [1] &quot;character&quot; Допустим, мы хотим взять из каждого диалога выборку размером 1000 слов, то есть применить функцию sample() к элементам списка. При помощи lapply() (l = list) это делается так: samples &lt;- lapply(corpus, sample, 1000, replace = T) Объект samples тоже представляет собой список, но теперь для всех диалогов одна длина вектора. Функция sapply() ведет себя так же, но упрощает результат до вектора или матрицы (s = simplify). s_sample &lt;- sapply(corpus[1:2], sample, 5, replace = F) s_sample ## Apology Charmides ## [1,] &quot;ὁ&quot; &quot;ὅταν&quot; ## [2,] &quot;ὀνειδίζω&quot; &quot;ὅστις&quot; ## [3,] &quot;καί&quot; &quot;ληρέω&quot; ## [4,] &quot;λέων&quot; &quot;ὅς&quot; ## [5,] &quot;οὐδείς&quot; &quot;γράμμα&quot; Поскольку это список, то применить грамматику dplyr не очень удобно, но корпус stylo легко превращается в тиббл: corpus_df &lt;- stack(corpus) head(corpus_df) ## values ind ## 1 ὅστις Apology ## 2 μέν Apology ## 3 σύ Apology ## 4 ὦ Apology ## 5 ἀνήρ Apology ## 6 ἀθηναῖος Apology Приведем в порядок: corpus_tbl &lt;- corpus_df %&gt;% as_tibble() %&gt;% relocate(ind, .before = values) %&gt;% rename(title = ind, word = values) corpus_tbl ## # A tibble: 503,475 × 2 ## title word ## &lt;fct&gt; &lt;chr&gt; ## 1 Apology ὅστις ## 2 Apology μέν ## 3 Apology σύ ## 4 Apology ὦ ## 5 Apology ἀνήρ ## 6 Apology ἀθηναῖος ## 7 Apology πάσχω ## 8 Apology ὑπό ## 9 Apology ὁ ## 10 Apology ἐμός ## # ℹ 503,465 more rows Теперь повторные выборки можно делать так: samples &lt;- corpus_tbl %&gt;% group_by(title) %&gt;% sample_n(size = 1000, replace = T) dim(samples) # видно, что на каждый диалог приходится ровно 1000 слов ## [1] 26000 2 И мы снова обошлись без цикла! 5.6 Purrr Настоящая мощь итерации – это пакет purrr из семейства tidyverse18. Но это с непривычки может быть непросто. You should never feel bad about using a loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work. — Hadley Wickham &amp; Garrett Grolemund Основная функция этого пакета – map() – имеет 23 вариации19. Главное достоинство map – не скорость, а ясность: код проще писать и читать (wickham2016?). Основные функции: map(.x, .f, ..., .progress = FALSE) map_lgl(.x, .f, ..., .progress = FALSE) map_int(.x, .f, ..., .progress = FALSE) map_dbl(.x, .f, ..., .progress = FALSE) map_chr(.x, .f, ..., .progress = FALSE) Другие: map_if() imap() lmap() map2() map_if() modify() и др. Итерации в purrr – очень большая тема20, и здесь рассмотрим только некоторые примеры. 5.6.1 map_df() и map_dbl() Получив на входе тиббл, map применяет заданную функцию к каждому столбцу. hapax_plato &lt;- as_tibble(hapax_plato) map_df(hapax_plato, center) ## # A tibble: 26 × 3 ## words hapax ratio ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -10619. -111. -0.00315 ## 2 -11053. -116. -0.00315 ## 3 -1420. -24.7 -0.000154 ## 4 -14414. -42.7 0.0138 ## 5 -15195. -128. -0.00215 ## 6 -6911. -59.7 -0.000154 ## 7 -14183. -132. -0.00415 ## 8 6973. -21.7 -0.00215 ## 9 -15004. -135. -0.00415 ## 10 -15340. -115. 0.000846 ## # ℹ 16 more rows Функции map – pipeable, поэтому можно записать это так: hapax_plato %&gt;% map_df(center) Формат выводимых данных предсказуем. Например, если на выходе требуется числовой вектор, то используем суффикс dbl: round(map_dbl(hapax_plato, mean), 3) ## words hapax ratio ## 19364.423 146.692 0.007 5.6.2 map2() map2() принимает на входе сразу два вектора и подходит в тех случаях, когда необходимо несколько раз вызывать одну и ту же функцию с двумя аргументами21. mean = list(1, 10, 100) sd = list(0.5, 5, 50) map2(mean, sd, rnorm, n = 3) ## [[1]] ## [1] -0.2473526 0.5568663 0.2478486 ## ## [[2]] ## [1] 23.94185 14.36832 13.72722 ## ## [[3]] ## [1] 131.7252 65.0547 101.8554 Аргументы, которые меняются при каждом вызове, пишутся до функции; аргументы, которые остаются неизменны, – после. Добавить картинку про мэп2 Если у функции больше двух аргументов, то используется pnorm(). Пример применения функции map2() в анализе текста: создание скользящего окна22. Подробный разбор в видео library(slider) windows &lt;- slide(corpus_tbl[1:36,], ~.x, .after = 6) out &lt;- map2(.x = windows, .y = 1:length(windows), ~ mutate(.x, window_id = .y)) # out is a list out[2] ## [[1]] ## # A tibble: 7 × 3 ## title word window_id ## &lt;fct&gt; &lt;chr&gt; &lt;int&gt; ## 1 Apology μέν 2 ## 2 Apology σύ 2 ## 3 Apology ὦ 2 ## 4 Apology ἀνήρ 2 ## 5 Apology ἀθηναῖος 2 ## 6 Apology πάσχω 2 ## 7 Apology ὑπό 2 5.7 Furrr Про параллельные вычисления, если останутся силы. https://r4ds.had.co.nz/iteration.html↩︎ https://dplyr.tidyverse.org/reference/mutate_all.html↩︎ https://dplyr.tidyverse.org/articles/colwise.html↩︎ https://rdrr.io/cran/stylo/↩︎ https://purrr.tidyverse.org/↩︎ https://adv-r.hadley.nz/functionals.html↩︎ См., например: https://www.emilhvitfeldt.com/post/2018-01-08-purrr-tips-and-tricks/↩︎ https://adv-r.hadley.nz/functionals.html↩︎ https://smltar.com/embeddings.html#understand-word-embeddings-by-finding-them-yourself↩︎ "],["blocks.html", "Тема 6 Blocks 6.1 Equations 6.2 Theorems and proofs 6.3 Callout blocks", " Тема 6 Blocks 6.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{6.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (6.1). 6.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 6.1. Theorem 6.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 6.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["sharing-your-book.html", "Тема 7 Sharing your book 7.1 Publishing 7.2 404 pages 7.3 Metadata for sharing", " Тема 7 Sharing your book 7.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 7.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 7.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
