[["index.html", "Компьютерный анализ текста в R Тема 1 О курсе 1.1 Благодарности", " Компьютерный анализ текста в R Ольга Алиева 2023-07-16 Тема 1 О курсе Этот сайт содержит материалы к курсу “Компьютерный анализ текста в R”. Курс находится в разработке, и материалы постоянно обновляются. Если вы заметили ошибку или опечатку, можно писать на адрес oalieva@hse.ru. 1.1 Благодарности Будут добавлены позже "],["начало-работы-с-r.html", "Тема 2 Начало работы с R 2.1 Что такое R? 2.2 Пакеты и виньетки 2.3 Если не хватает пакетов 2.4 О воспроизводимости 2.5 Что мы (не) будем делать? 2.6 RStudio 2.7 Установка 2.8 Начало работы 2.9 R как калькулятор 2.10 Операторы присваивания 2.11 Векторы 2.12 Списки 2.13 Матрицы 2.14 Таблицы 2.15 Шорткаты", " Тема 2 Начало работы с R 2.1 Что такое R? R — это язык программирования для статистической обработки данных и работы с графикой. Он создан в 90-х гг. на факультете статистики Оклендского университета. Иными словами, его делали статистики и для статистиков. Поэтому он прекрасно подходит для анализа данных, статистических вычислений и машинного обучения, а значит востребован в науке. Язык R — один из самых распространённых в научной среде. Им пользуются математики, биологи, генетики и другие учёные, которым нужно проводить статистические исследования и строить модели. Поэтому язык R нужно изучать тем, кто планирует заниматься научными исследованиями. — Яндекс Практикум Блог После установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Но за счет того, что R распространяется свободно, постоянно появляются новые алгоритмы, созданные внутри экспертного сообщества и тоже доступные для всех. Как и любой язык, R растет и развивается. 2.2 Пакеты и виньетки Если в базовой инсталляции R нет нужного решения – имеет смысл поискать в библиотеке пакетов. Пакет – это набор функций и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории CRAN доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub, например пакет Dracor, к которому я буду обращаться в рамках этого курса. Некоторые функции, которые вы найдете в пакетах, частично дублируют друг друга – это нормально, как и в естественном языке, “сказать” что-то можно разными способами. Несмотря на то, что R создавался изначально для работы со статистикой, система свободно распространяемых модулей значительно расширяет круг задач, которые можно решать на этом языке. Например, благодаря модулю Shiny можно создавать приложения и встраивать их в веб-страницы, а модуль Leaflet позволяет создавать интерактивные карты. Одну из них мы сделали в рамках проекта Antibarbari HSE. В рамках этого курса мы познакомимся и с модулями для машинного обучения. Нейросети в R тоже можно строить, но мы пока не будем. По технической документации и так называемым “виньеткам” можно понять, какой пакет вам нужен. Например, вот так выглядит виньетка пакета RPerseus, при помощи которого можно получить доступ к корпусу греческой и латинской литературы. Бывают еще “пакеты пакетов”, то есть очень большие семейства функций, своего рода “диалекты” R. Таково, например, семейство tidyverse, объединяемое идеологией “опрятных” данных. Про него мы еще будем говорить. 2.3 Если не хватает пакетов Это самое интересное. Если вы работаете в программе с графическим интерфейсом (SPSS, Minitab), то вы вынуждены формулировать свою задачу так, чтобы “вписаться” в набор кнопок, предусмотренных разработчиком. В R, столкнувшись с особой задачей, вы просто пишете под нее особую функцию. Новую функцию не обязательно публиковать в составе пакета – можно сохранить в рабочую директорию (с расширением .R) и наслаждаться самому. По мере того, как развиваются ваши навыки программирования, вы можете ставить и решать все более сложные и интересные задачи. 2.4 О воспроизводимости Когда вы решите опубликовать свое исследование, то и код к нему придется опубликовать (как правило, для этого используется GitHub) – поэтому надо сразу привыкать кодить так, чтобы ваш код был понятен другим. Например, добавлять пояснения при помощи знака # (как в Python) # случайный набор чисел из нормального распределения x &lt;- rnorm(1000) # случайная выборка из этого набора y &lt;- sample(x, 100) В идеале, впрочем, вы поясняете не то, что код делает (при грамотном кодинге это должно быть самоочевидо), а зачем. В этом примере код, правда, настолько простой, что не требует особых пояснений. Но в больших проектах от “читабельности” кода зависит не только то, поймет ли вас потенциальный рецензент, но и сможете ли вы сами вспомнить, какая строчка за что отвечает. Также это позволит вернуться к проекту через некоторое время и быстро вспомнить, что там происходит. Если вы получите интересные результаты и решите их опубликовать, то выложить в открытый доступ придется не только код, но и данные (если они не защищены копирайтом или другими ограничениями). Таким образом рецензент или другие ученые, которые будут читать вашу статью, сможет перепроверить ваши выводы. Ученые так делают! И это еще один довод в пользу того, чтобы научиться программировать, а не полагаться на ПО с графическим интерфейсом. 2.5 Что мы (не) будем делать? Хотя возможности R очень широки, мы будем заниматься в основном анализом текстовых данных. “Текст” в данном случае можно понимать как зафиксированную (в машиночитаемом виде) речь: от отзыва на товар до романа. Но в основном данные я подбираю таким образом, чтобы они были интересны гуманитариям. Мы не будем анализировать звучащую речь (хотя это тоже можно делать в R). И мы не будем заниматься распознаванием рукописных символов, для этого есть гораздо другие мощные инструменты. Веб-скрапинг и нейронные сети тоже не входят в число тем этого курса. Курс включает в себя три основных блока и 24 урока: общее введение в R (темы 1-6) text-mining (темы 7-13) статистика и статистическое обучение (14-22) Еще два урока посвящены модулям Plotly и Leaflet. Если вы плохо представляете, на что вообще способны количественные методы в гуманитаристике, посмотрите видео панельной дискуссии “Цифровые инструменты и методы: в чем их польза и как им обучить гуманитария?” (НИУ ВШЭ, 2023 г.). Это видео о том, зачем. О том, как – дальше. 2.6 RStudio Работать в R мы будем с использованием RStudio, которая представляет собой свободную среду разработки (IDE) программного обеспечения с открытым исходным кодом для языка программирования R. Наша задача в этом уроке – установить R и R Studio и убедиться, что все работает; научиться самостоятельно находить помощь, совершать несложные вычисления. 2.7 Установка Установить R Скачать R для Windows: https://cran.r-project.org/bin/windows/ Скачать R для Mac: https://cran.r-project.org/bin/macosx/ Установить R Studio Скачать: https://www.rstudio.com/products/rstudio/download/ (достаточно бесплатной версии) На MacOS для работы библиотеки Stylo также понадобится установить XQuartz: https://www.xquartz.org/ 2.8 Начало работы После установки и запуска RStudio вы увидите вот такие четыре панели (их названия подписаны на картинке): RStudio Panes По ссылке можно подробнее прочитать, что за что отвечает (и как это поменять). Для начала попробуйте получить информацию о сессии, введя в консоли такую команду: sessionInfo() sessionInfo() – это функция. За названием функции всегда следуют круглые скобки, внутри которых могут находиться аргументы функции. О функциях можно думать как о глаголах (“сделай то-то!”). Аргументы – это что-то вроде дополнений и обстоятельств. (Кстати, в “диалекте” tidyverse есть функции-наречия, так что аналогия законная.) Аргументы могут быть обязательные и необязательные. Чтобы узнать, каких аргументов требует функция, надо вызывать help: ?mean(). Также можно (и нужно) читать техническую документацию к пакетам. Уточнить свою рабочую директорию (в которой R будет искать и сохранять файлы) можно при помощи функции getwd() без аргументов. Установить рабочую директорию можно при помощи функции setwd(), указав в качестве аргумента путь к рабочей директории на вашем компьютере (в кавычках, так как это символьный вектор). В моем случае это выглядит так: setwd(&quot;/Users/olga/R_Workflow/&quot;) Также для выбора рабочей директории можно использовать меню R Session &gt; Set Working Directory. Пакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню Tools &gt; Install Packages. Также можно устанавливать пакеты из консоли. Установим пакет для стилометрического анализа: install.packages(&quot;stylo&quot;) Для подключения используем функцию library(), которой передаем в качестве аргумента название пакета без кавычек: library(stylo) Что еще надо знать: как создавать проекты в R и почему это удобно 1 как создавать и хранить файлы с кодом 2.9 R как калькулятор Можно использовать R как калькулятор. Для этого вводим данные рядом с символом приглашения &gt;, который называется prompt. sqrt(4) # квадратный корень ## [1] 2 2^3 # степень ## [1] 8 log10(100) #логарифм ## [1] 2 Если в начале консольной строки стоит +, значит предыдущий код не завершен. Например, вы забыли закрыть скобку функции. Ее можно дописать на следующей строке. Попробуйте набрать sqrt(2 в консоли. 2.10 Операторы присваивания Чтобы в окружении появился новый объект, надо присвоить результат вычислений какой-нибудь переменной при помощи оператора присваивания &lt;- (Alt + - (Windows) или Option + - (Mac)). Знак = также работает как оператор присваивания, но не во всех контекстах, поэтому им лучше не пользоваться. x &lt;- 2 + 2 # создаем переменную y &lt;- 0.1 # создаем еще одну переменную x &lt;- y # переназначаем x + y ## [1] 0.2 Имя переменной, как и имя функции, может содержать прописные и строчные буквы, точку и знак подчеркивания. Функция c() (concatenation) позволяет собрать несколько элементов в единый вектор: x &lt;- c(3, 5, 7) x_mean &lt;- mean(x) # также возможно x.mean или xMean x_mean ## [1] 5 В диалекте tidyverse предпочтение отдается подчеркиванию, а не точке; здесь сказывается влияние синтаксиса Python, где через точку получают доступ к методам объекта. Будьте внимательны: R чувствительна к регистру! Объекты, предназначенные для хранения данных, – это отдельные переменные, векторы, матрицы и массивы, списки, факторы, таблицы данных. Функции – это поименованные программы, предназначенные для создания новых объектов или выполнения определенных действий над ними (С. Мастицкий и В. Шитиков 2015, 24) Чтобы получить список всех объектов в окружении, используется функция ls(). Удалять объекты можно при помощи rm(). Функции можно вкладывать друг в друга: rm(list = ls()) # удаляет все объекты в окружении 2.11 Векторы В языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента. x &lt;- 2 class(x) # числовой вектор ## [1] &quot;numeric&quot; length(x) # длина вектора ## [1] 1 y &lt;- c() # создадим пустой вектор y # при попытке распечатать получаем NULL ## NULL length(y) # длина равна 0 ## [1] 0 NULL означает, что значение не существует; NA (not available) – что оно существует, но неизвестно. Поэтому mean(c(1, NA, 2)) выдаст ошибку, а mean(c(1, NULL, 2)) вернет среднее. В первом случае можно использовать дополнительный аргумент: mean(c(1, NA, 2), na.rm=T). Подробнее см. (Мэтлофф 2019). Основные типы данных, с которыми мы будем работать, следующие: целое число (integer) число с плавающей точкой (numeric, также называются double, то есть число двойной точности) строка (character) логическая переменная (logical) категориальная переменная, или фактор (factor) # проверить тип данных x &lt;- sqrt(2) class(x) ## [1] &quot;numeric&quot; is.integer(x) ## [1] FALSE is.numeric(x) ## [1] TRUE При попытке объединить в единый вектор данные разных типов, они будут принудительно приведены к одному типу: x &lt;- c(TRUE, 1, 3, FALSE) x # логические значения переработаны в числовые ## [1] 1 1 3 0 y &lt;- c(1, &quot;a&quot;, 2, &quot;лукоморье&quot;) # строки всегда в кавычках y # числа превратились в строки ## [1] &quot;1&quot; &quot;a&quot; &quot;2&quot; &quot;лукоморье&quot; Типы векторов в R Логические векторы можно получить в результате применения логических выражений (== “равно”, != “не равно”, &lt;= “меньше или равно”) к данным других типов: x &lt;- c(1:10) # числа от 1 до 10 y &lt;- x &gt; 5 y # значения TRUE соответствуют единице, поэтому их можно складывать ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE sum(y) ## [1] 5 Функции all() и any() также возвращают логические значения: x &lt;- 10:20 any(x == 15) ## [1] TRUE all(x &gt; 9) ## [1] TRUE Существуют различные способы сгенерировать векторы: seq(1, 5, 0.5) ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 rep(&quot;foo&quot;, 5) ## [1] &quot;foo&quot; &quot;foo&quot; &quot;foo&quot; &quot;foo&quot; &quot;foo&quot; Векторы можно индексировать, то есть забирать из них какие-то элементы: x &lt;- seq(1, 5, 0.5) x[4:5] # индексы начинаются с 1 (в отличие от Python) ## [1] 2.5 3.0 Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет переработан, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины. x &lt;- 2; y &lt;- c(10, 20, 30); z &lt;- c(5, 6, 7) y / x ## [1] 5 10 15 x + y ## [1] 12 22 32 y + z ## [1] 15 26 37 Факторы внешне похожи на строки, но в отличие от них хранят информацию об уровнях категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой. t &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) t ## [1] A B C ## Levels: A B C 2.12 Списки Списки, или рекурсивные векторы (в отличие от атомарных векторов), могут хранить данные разных типов. list = list(a = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), b = c(1, 2, 3), c = c(T, F, T)) list ## $a ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## $b ## [1] 1 2 3 ## ## $c ## [1] TRUE FALSE TRUE Можно получить доступ как к элементам списка целиком, так и к их содержимому. list$a # обращение к поименованным элементам ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; list[2] # одинарные квадратные скобки извлекают элемент списка целиком ## $b ## [1] 1 2 3 class(list[2]) ## [1] &quot;list&quot; list[[2]] # элементы второго элемента ## [1] 1 2 3 class(list[[2]]) ## [1] &quot;numeric&quot; list$c[1]# первый элемент второго элемента ## [1] TRUE Обратите внимание, что list[2] и list[[2]] возвращают объекты разных классов. Нам это еще понадобится при работе с XML. Индексирование списка в R Если пройти по ссылке, можно увидеть еще несколько замечательных иллюстраций этой мысли🧂 2.13 Матрицы Матрица – это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим. M = matrix(c(1, 2, 3, 4), nrow = 2) M # все ок ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 M = matrix(c(1, 2, 3, &quot;a&quot;), nrow = 2) M # все превратилось в строку! ## [,1] [,2] ## [1,] &quot;1&quot; &quot;3&quot; ## [2,] &quot;2&quot; &quot;a&quot; В матрице есть строки и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер строки, потом номер столбца. M = matrix(c(1, 2, 3, 4), nrow = 2) M[1, ] # первая строка полностью ## [1] 1 3 M[,2] # второй столбец полностью ## [1] 3 4 M[1,1] # одно значение ## [1] 1 Обратите внимание, как меняется размерность при индексировании. M = matrix(c(1, 2, 3, 4), nrow = 2) class(M) ## [1] &quot;matrix&quot; &quot;array&quot; dim(M) # функция для извлечения измерений ## [1] 2 2 class(M[1, ]) # первая строка полностью ## [1] &quot;numeric&quot; dim(M[1, ]) ## NULL Попытка узнать измерения вектора возвращает NULL, потому что с точки зрения R векторы не являются матрицами из одного столбца или одной строки, и потому не имеют измерений. С другой стороны, можно создать матрицу, в которой будет одна строка или один столбцец. При выводе они выглядят не так, как обычные векторы. Хотя казалось бы. # вектор-строка C = matrix(c(1, 2, 3), nrow = 1) C ## [,1] [,2] [,3] ## [1,] 1 2 3 # вектор-столбец D = matrix(c(1, 2, 3), nrow = 3) D ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 Над числовыми матрицами в R можно совершать разные операции из линейной алгебры; многие из них нам понадобятся, когда мы будем говорить о латентно-семантическом анализе. Пока лишь несколько полезных функций. # в квадратной матрице есть главная и побочная диагонали M = matrix(c(1, 2, 3, 4), nrow = 2) # ее мы распечатывали выше diag(M) ## [1] 1 4 # если поставить матрицу на бок, то получится транспонированная матрица t(M) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 # матрицу можно умножить на скаляр, то есть на обычное число. M * 3 ## [,1] [,2] ## [1,] 3 9 ## [2,] 6 12 # матрицы одного размера можно складывать M + M ## [,1] [,2] ## [1,] 2 6 ## [2,] 4 8 Матрицы также можно умножать на другие матрицы и на векторы. Но это уже линан, и мы вернемся к этому в другой раз. Пока, если хотите, можете посмотреть видео. Подробнее об элементах линейной алгебры в R см. (А. Буховец и П. Москалев 2015). 2.14 Таблицы Таблицы (кадры данных, data frames) – это двумерные объекты (как и матрицы). Датафреймы отличаются от матриц тем, что их столбцы могут хранить данные разного типа. Если списки являются разнородными аналогами векторов в одном измерении, кадры данных являются разнородными аналогами матриц для двухмерных данных (Мэтлофф 2019, 133). # создание датафрейма df &lt;- data.frame(names = c(&quot;A&quot;, &quot;B&quot;), age = c(10, 11)) df ## names age ## 1 A 10 ## 2 B 11 # извлечение элементов df$names # забирает весь столбец ## [1] &quot;A&quot; &quot;B&quot; df[,&quot;names&quot;] # то же самое, другой способ ## [1] &quot;A&quot; &quot;B&quot; df[1, ] # забирает ряд ## names age ## 1 A 10 Потренируемся на датасете с данными о гапаксах в диалогах Платона. Гапакс – это слово, которое встречается один раз в корпусе или тексте. Этот датасет позволяет перепроверить выводы Льюиса Кэмпбелла, профессора Сент-Эндрюсского университета в Шотландии. Еще 1867 г., впервые применив количественный метод для датировки диалогов Платона, он пришел к выводу, что для “позднего” стиля Платона, среди прочего, характерно обилие редкой лексики (Campbell 1867, xxxi). В корпус подлинных диалогов Кэмпбелл включал 26 текстов, которые делил на три хронологические группы. Свои вычисления он делал вручную, а мы можем попробовать все пересчитать в R. ## dialogue words hapax ratio group ## 1 Apology 8745 36 0.004 1 ## 2 Charmides 8311 31 0.004 1 ## 3 Cratylus 17944 122 0.007 1 ## 4 Critias 4950 104 0.021 3 ## 5 Crito 4169 19 0.005 1 ## 6 Euthydemus 12453 87 0.007 1 Вот так выглядят наши данные. Функция class() позволяет убедиться, что это датафрейм. ## [1] &quot;data.frame&quot; Потренируемся работать с данными в таблицах. # узнать имена столбцов colnames(hapax_plato) ## [1] &quot;dialogue&quot; &quot;words&quot; &quot;hapax&quot; &quot;ratio&quot; &quot;group&quot; # извлечь ряд(ы) по значению hapax_plato[hapax_plato$dialogue == &quot;Parmenides&quot;, ] ## dialogue words hapax ratio group ## 16 Parmenides 15155 20 0.001 2 # узнать тип данных в столбцах str(hapax_plato) ## &#39;data.frame&#39;: 26 obs. of 5 variables: ## $ dialogue: chr &quot;Apology&quot; &quot;Charmides&quot; &quot;Cratylus&quot; &quot;Critias&quot; ... ## $ words : chr &quot;8745&quot; &quot;8311&quot; &quot;17944&quot; &quot;4950&quot; ... ## $ hapax : chr &quot;36&quot; &quot;31&quot; &quot;122&quot; &quot;104&quot; ... ## $ ratio : chr &quot;0.004&quot; &quot;0.004&quot; &quot;0.007&quot; &quot;0.021&quot; ... ## $ group : num 1 1 1 3 1 1 1 1 1 1 ... # отобрать ряды по количеству слов hapax_plato[hapax_plato$words &gt; 10000, ] ## dialogue words hapax ratio group ## 1 Apology 8745 36 0.004 1 ## 2 Charmides 8311 31 0.004 1 ## 3 Cratylus 17944 122 0.007 1 ## 4 Critias 4950 104 0.021 3 ## 5 Crito 4169 19 0.005 1 ## 6 Euthydemus 12453 87 0.007 1 ## 7 Euthyphro 5181 15 0.003 1 ## 8 Gorgias 26337 125 0.005 1 ## 9 HippiasMinor 4360 12 0.003 1 ## 10 Ion 4024 32 0.008 1 ## 11 Laches 7674 27 0.004 1 ## 12 Laws 103193 914 0.009 3 ## 13 Lysis 6980 49 0.007 1 ## 14 Menexenus 4808 43 0.009 1 ## 15 Meno 9791 30 0.003 1 ## 16 Parmenides 15155 20 0.001 2 ## 17 Phaedo 21825 140 0.006 1 ## 18 Phaedrus 16645 228 0.014 2 ## 19 Philebus 17668 64 0.004 3 ## 20 Protagoras 17795 102 0.006 1 ## 21 Republic 88878 668 0.008 2 ## 22 Sophist 16024 107 0.007 3 ## 23 Statesman 16953 180 0.011 3 ## 24 Symposium 17461 127 0.007 1 ## 25 Theaetetus 22489 162 0.007 2 ## 26 Timaeus 23662 370 0.016 3 # преобразовать тип данных в столбцах hapax_plato$group &lt;- as.factor(hapax_plato$group) hapax_plato[,2:4] &lt;- sapply(hapax_plato[,2:4],as.numeric) # подробнее о функции `sapply()` в уроке про итерации И еще с датафреймами полезна функция summary(): summary(hapax_plato) ## dialogue words hapax ratio group ## Length:26 Min. : 4024 Min. : 12.00 Min. :0.001000 1:16 ## Class :character 1st Qu.: 7154 1st Qu.: 31.25 1st Qu.:0.004000 2: 4 ## Mode :character Median : 15590 Median : 94.50 Median :0.007000 3: 6 ## Mean : 19364 Mean :146.69 Mean :0.007154 ## 3rd Qu.: 17907 3rd Qu.:136.75 3rd Qu.:0.008000 ## Max. :103193 Max. :914.00 Max. :0.021000 2.15 Шорткаты Этот раздел я допишу позже. References "],["визуализации.html", "Тема 3 Визуализации 3.1 Базовый R 3.2 Lattice 3.3 Ggplot2 3.4 Экспорт графиков из среды R", " Тема 3 Визуализации 3.1 Базовый R В R существуют три основные системы построения графиков, которые могут быть полезны для достижения разных целей. Базовый R – это самая старая система, и в ее основе лежит идея палитры художника2. Идея заключается в том, что у вас есть чистый холст, на который вы добавляете что-то одно за другим: например, сначала вы создаете диаграмму рассеяния с несколькими точками, затем вы добавляете метки, линию регрессии, заголовки и т.п. Каждая деталь графика занимает еще одну строчку кода. Это интуитивно понятная модель, потому что часто в самом начале, исследуя данные, мы часто не знаем, какой график мы хотим построить. Обычно мы начинаем это построение с функции plot(), а затем добавляем функции, которые аннотируют график. Вот простой пример на данных о гапаксах у Платона, которые мы видели раньше. Чтобы построить диаграмму рассеяния (scatter plot), нужно передать функции plot() в качестве аргументов названия тех столбцов, которые мы хотим изобразить по осям x и y. Это можно записать так: plot(x, y). Или так: plot(y ~ x). Знак ~ (тильда) указывает на функцию. attach(hapax_plato) plot(hapax ~ words) Это можно записать и иначе: plot(hapax_plato$hapax ~ hapax_plato$words). Результат будет одинаковый. Теперь беремся за палитру. Данные скучились в левом нижнем углу и потому плохо читаются. Мы можем пожертвовать двумя очень длинными диалогами (это “Государство” и “Законы”) и сделать zoom in, указав вручную границы осей. attach(hapax_plato) plot(hapax ~ words, xlim = c(0, 30000), ylim = c(0, 500)) Но так мы все-таки теряем какую-то информацию – а вдруг она важная? Еще один способ справиться со слипшимися данными – преобразовать их. Применим логарифмическое преобразование. Обратите внимание, как меняются значения на осях. attach(hapax_plato) options(scipen=999) # избавляет от научной нотации plot(words, hapax, log = &quot;xy&quot;) # добавим текст text(hapax ~ words, labels = dialogue, pos = 2, cex = 0.7) Уже гораздо интереснее! Попробуем обозначить цветом и формой пересказанные и прямые диалоги. Форма задается внутри функции plot() при помощи атрибута pch. Числовые значения этого атрибута соответствуют следующим значкам. Мы используем 2, 3 и 5. Значения атрибута pch Перестраиваем наш график. attach(hapax_plato) options(scipen=999) # избавляет от научной нотации plot(words, hapax, log = &quot;xy&quot;, col = c(&quot;darkblue&quot;, &quot;darkgreen&quot;, &quot;darkred&quot;)[group], pch = c(2, 3, 5)[group]) text(hapax ~ words, labels = dialogue, pos = 2, cex = 0.7, col = c(&quot;darkblue&quot;, &quot;darkgreen&quot;, &quot;darkred&quot;)[group]) Некоторые названия перекрываютcя (с этим мы научимся бороться позже), но все равно намного понятнее. Теперь можем поменять шрифт и, например, добавить линию регрессии (не хватает легенды, но что-то уже нет сил). attach(hapax_plato) options(scipen=999) # избавляет от научной нотации plot(words, hapax, log = &quot;xy&quot;, col = c(&quot;darkblue&quot;, &quot;darkgreen&quot;, &quot;darkred&quot;)[group], pch = c(2, 3, 5)[group], family = &quot;serif&quot;) text(hapax ~ words, labels = dialogue, pos = 2, cex = 0.7, col = c(&quot;darkblue&quot;, &quot;darkgreen&quot;, &quot;darkred&quot;)[group], family = &quot;serif&quot;) # добавим линию регрессии my_lm &lt;- lm(hapax_plato$hapax ~ hapax_plato$words) abline(my_lm, lty = &quot;dashed&quot;, col = &quot;darkgrey&quot;, untf = T) # и заголовок title(main = &quot;Число гапаксов в зависимости от длины диалога&quot;) При помощи графических параметров3 можно контролировать множество настроек. Но в этом и недостаток базовой графики. Не всем хватает терпения и вкуса этим заниматься, поэтому эта система сейчас не очень употребительна. Попробуйте интерпретировать график, который у нас получился. Прав ли был профессор Кэмпбелл, утверждая, что высокая доля гапаксов характерна для “поздних” текстов? Исходите из того, что единственный текст, о котором точно известно, что он поздний – это “Законы”. Судя по графику, количество гапаксов зависит от количества слов в тексте. Чем длиннее текст, тем больше вероятность встретить там редкое слово. 3.2 Lattice Система Lattice (букв. “Решетка”) была разработана специально для анализа многомерных данных (Sarkar 2008). Тут должны быть графики цветочки Например, мы сравниваем точность классификации текстов в зависимости от длины отрывка и количества слов-предикторов. Это уже три переменные (длина – количество слов – точность). Система решеток, или панелей, позволяет представить такие многомерные данные. Многомерно нет слов! В базовом R это тоже можно сделать, изменив графические параметры: par(mfrow = c(1,2)) # вот тут указываем число рядов и столбцов plot(hapax_plato$hapax ~ hapax_plato$words) plot(hapax_plato$ratio ~ hapax_plato$group) Но видно, что пространство при этом расходуется неэффективно. Кроме того, к таким графикам сложно создавать заголовки и подзаголовки, подбирать подписи и т.п. Все эти задачи решает Lattice. Идея этой системы в том, что каждый график строится с помощью одного вызова функции. При этом необходимо сразу указать большое количество информации, чтобы у фунцкии было достаточно данных для построения графика. library(lattice) attach(hapax_plato) # после вертикальной черты указана переменная, которая используется для группировки данных; в нашем случае номер группы (по Кэмпбеллу) xyplot(hapax ~ words | group, data = hapax_plato, scales=list(x=list(log=10))) # трансформация по одной оси Недостаток Lattice, однако, в том, что бывает сложно аннотировать отдельные панели, а также приходится сразу задавать весь график в одном вызове функции. Это не всегда удобно. После создания графика уже ничего нельзя добавить или убавить. 3.3 Ggplot2 Но настоящая графическая сила R – это пакет ggplot2. В его основе лежит идея “грамматики графических элементов” Лиланда Уилкинсона (Мастицкий 2017), и он позволяет объединить достоинства базовой графики R и Lattice. С одной стороны, вы можете постепенно достраивать график, добавляя элемент за элементом; с другой стороны, множество параметров подбираются автоматически, как в Lattice. 3.3.1 Быстрое решение: qplot() Настройки по умолчанию хорошо видно на графике ниже; их легко перенастроить. library(ggplot2) # загружается сразу с tidyverse options(scipen = 999) qplot(words, hapax, data = hapax_plato, log = &quot;xy&quot;) ## Warning: `qplot()` was deprecated in ## ggplot2 3.4.0. ## This warning is displayed ## once every 8 hours. ## Call ## `lifecycle::last_lifecycle_warnings()` ## to see where this warning was ## generated. Функция qplot() – это быстрое решение для задач визуализации. В современных версиях ggplot использование функции qplot() не рекомендуется (deprecated), чтобы побудить пользователей изучать ggplot() как более совершенный инструмент. В данном случае мы построили диаграмму рассеяния, используя логарифмическую трансформацию по двум осям. Можно также выделить цветом различные типы диалогов, изменить размер точек, их прозначность и т.п. qplot(words, hapax, data = hapax_plato, log = &quot;xy&quot;, col = group, size = 1.5) + theme(legend.position = &quot;none&quot;) Диаграмма размаха (о ней подробнее можно посмотреть здесь) удобна в тех случаях, когда необходимо представить обобщенную статистическую информацию о распределении значений количественной переменной в разных группах. attach(hapax_plato) qplot(group, ratio, data = hapax_plato, geom = &quot;boxplot&quot;, color = group) Диаграмму размаха можно совместить с одномерной диаграммой рассеяния. qplot(group, ratio, data = hapax_plato, geom = c(&quot;boxplot&quot;, &quot;jitter&quot;), color = group) # вместо color можно использовать shape, который отвечает за форму элементов 3.3.2 Слой за слоем: ggplot() Для более детальной настройки графика рекомендууется использовать функцию ggplot(), которая имеет два основных аргумента: data и aes (англ. aesthetics); последняя присваивает эстетические атрибуты геометрическим объектам, которые используются на графике. Эти объекты могут слоями накладываться друг на друга (Wickham and Grolemund 2017). Посмотрим, как это работает, на примере, столбиковой диаграммы. Такая диаграмма позволяет представить распределение как количественных, так и качественных переменных. Для примера возьмем датасет diorisis_meta, который хранит данные о древнегреческих текстах, доступных в репозитории Diorisis4. ## # A tibble: 6 × 5 ## name title date genre subgenre ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Achilles Tatius Leucippe and Clitophon 120 Narrative Novel ## 2 Aelian De Natura Animalium 230 Technical Natural History ## 3 Aelian Epistulae Rusticae 230 Letters Letters ## 4 Aelian Varia Historia 200 Essays Miscellanea ## 5 Aeneas Tacticus Poliorcetica -350 Technical Military ## 6 Aeschines Against Ctesiphon -330 Oratory Oratory Столбиковая диаграмма позволяет увидеть, тексты каких жанров чаще всего встречаются в этом корпусе. library(tidyverse) diorisis_meta %&gt;% group_by(genre) %&gt;% count() %&gt;% ggplot(aes(reorder(genre, n), n, fill = genre)) + geom_bar(stat = &quot;identity&quot;) + coord_flip() Точечная диаграмма, или dotplot, подходит для тех случаев, когда мы исследуем распределение наблюдений для разных групп данных, причем наблюдений не очень много. Например, мы можем отразить распределение текстов в корпусе по годам. Категориальную переменную (например, жанр) можно дополнительно закодировать цветом (зд. подробнее о том, что можно увидеть на этом графике). diorisis_meta %&gt;% ggplot(aes(date, fill = factor(genre))) + geom_dotplot(binwidth = 10, stackdir = &quot;centerwhole&quot;, binpositions = &quot;all&quot;) + scale_y_continuous(NULL, breaks = NULL) + scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) Различные группы данных можно выделять не только цветом и формой, но и помещать каждую в свое окошко (facet). Попробуем выяснить: сколько поджанров в каждом жанре? diorisis_meta %&gt;% group_by(genre, subgenre) %&gt;% count %&gt;% filter(genre %in% c(&quot;Poetry&quot;, &quot;Technical&quot;)) %&gt;% ggplot(aes(reorder(subgenre, n), n, fill = subgenre)) + geom_col(show.legend = F) + facet_wrap(~genre, scales = &quot;free&quot;) + # вот здесь задаем группы coord_flip() Подробнее с разными видами графиков мы познакомимся дальше, но напоследок о том, как сделать так, чтобы текстовые подписи не наезжали друг на друга. library(ggrepel) hapax_plato %&gt;% ggplot(aes(words, hapax, col = group)) + geom_point(size = 1.2, alpha = 0.7, show.legend = F) + geom_label_repel(label = dialogue) + scale_x_log10() + scale_y_log10() + theme_bw() Ай, красота. 3.4 Экспорт графиков из среды R Способы: реализованные в R драйверы стандартных графических устройств; функция ggsave() меню программы RStudio. # код сохранит pdf в рабочую директорию pdf(file = &quot;Diorisis.pdf&quot;) diorisis_meta %&gt;% group_by(genre, subgenre) %&gt;% count %&gt;% filter(genre %in% c(&quot;Poetry&quot;, &quot;Technical&quot;)) %&gt;% ggplot(aes(reorder(subgenre, n), n, fill = subgenre)) + geom_col(show.legend = F) + facet_wrap(~genre, scales = &quot;free&quot;) + coord_flip() dev.off() # еще один способ сохранить последний график ggsave( filename = &quot;Diorisis.png&quot;, plot = last_plot(), device = &quot;png&quot;, scale = 1, width = NA, height = 500, units = &quot;px&quot;, dpi = 300 ) References "],["опрятные-данные.html", "Тема 4 Опрятные данные 4.1 Синтаксис tidyverse 4.2 Опрятные данные 4.3 Пример: буккроссинг", " Тема 4 Опрятные данные Tidy datasets are all alike, but every messy dataset is messy in its own way. — Hadley Wickham 4.1 Синтаксис tidyverse Существуют два основных “диалекта” R, один из которых опирается главным образом на функции и структуры данных базового R, а другой пользуется синтаксисом tidyverse (Winter 2020). Tidyverse – это семейство пакетов (метапакет), разработанных Хадли Уикхемом и др., которое включает в себя в том числе пакеты dplyr, ggplot2 и многие другие. # загрузить все семейство library(tidyverse) 4.1.1 Tibble Основная структура данных в tidyverse – это tibble, современный вариант датафрейма5. Тиббл, как говорят его разработчики, это ленивые и недовольные датафреймы: они делают меньше и жалуются больше6. Это позволяет решать проблемы на более ранних этапах, что, как правило, приводит к созданию более чистого и выразительного кода. Основные отличия от обычного датафрейма: текст по умолчанию конвертируется в строки, а не в факторы;7 усовершенствованный метод print(), не нужно постоянно вызывать head(); нет имен рядов; допускает синтаксически “неправильные” имена столбцов; при индексировании не меняет тип данных на вектор и др. load(&quot;./datasets/DiorisisMeta.Rdata&quot;) # распечатывает только первые 10 рядов, для каждого столбца указан тип данных, строки пронумерованы as_tibble(diorisis_meta) ## # A tibble: 784 × 5 ## name title date genre subgenre ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Achilles Tatius Leucippe and Clitophon 120 Narrative Novel ## 2 Aelian De Natura Animalium 230 Technical Natural History ## 3 Aelian Epistulae Rusticae 230 Letters Letters ## 4 Aelian Varia Historia 200 Essays Miscellanea ## 5 Aeneas Tacticus Poliorcetica -350 Technical Military ## 6 Aeschines Against Ctesiphon -330 Oratory Oratory ## 7 Aeschines Against Timarchus -347 Oratory Oratory ## 8 Aeschines The Speech on the Embassy -336 Oratory Oratory ## 9 Aeschylus Agamemnon -458 Tragedy Tragedy ## 10 Aeschylus Eumenides -458 Tragedy Tragedy ## # ℹ 774 more rows # индексирование head(as.data.frame(diorisis_meta)[, 1]) # возвращает вектор ## [1] &quot;Achilles Tatius&quot; &quot;Aelian&quot; &quot;Aelian&quot; &quot;Aelian&quot; ## [5] &quot;Aeneas Tacticus&quot; &quot;Aeschines&quot; as_tibble(diorisis_meta)[,1] # возвращает тиббл ## # A tibble: 784 × 1 ## name ## &lt;chr&gt; ## 1 Achilles Tatius ## 2 Aelian ## 3 Aelian ## 4 Aelian ## 5 Aeneas Tacticus ## 6 Aeschines ## 7 Aeschines ## 8 Aeschines ## 9 Aeschylus ## 10 Aeschylus ## # ℹ 774 more rows # имена столбцов df &lt;- data.frame(&#39;var 1&#39; = 1:2, two = 3:4) df ## var.1 two ## 1 1 3 ## 2 2 4 tbl &lt;- tibble(&#39;var 1&#39; = 1:2, two = 3:4) tbl ## # A tibble: 2 × 2 ## `var 1` two ## &lt;int&gt; &lt;int&gt; ## 1 1 3 ## 2 2 4 4.1.2 Dplyr Но самое главное, tibble подходит для “грамматики манипуляции данных”, лежащей в основе dplyr8. Эта грамматика предоставляет последовательный набор глаголов, которые помогают решать наиболее распространенные задачи манипулирования данными: mutate() добавляет новые переменные, которые являются функциями существующих переменных; select() выбирает переменные на основе их имен; filter() выбирает наблюдения на основе их значений; summarise() обобщает значения; arrange() изменяет порядок следования строк. Все эти глаголы естественным образом сочетаются с функцией group_by(), которая позволяет выполнять любые операции “по группам”, и с оператором pipe %&gt;% из пакета magrittr. В итоге получается более лаконичный и читаемый код, что можно показать на примере. diorisis_meta %&gt;% select(-subgenre) %&gt;% filter(genre == &quot;Narrative&quot;) %&gt;% # не нужны кавычки! group_by(name) %&gt;% count() %&gt;% arrange(-n) ## # A tibble: 20 × 2 ## # Groups: name [20] ## name n ## &lt;chr&gt; &lt;int&gt; ## 1 Plutarch 71 ## 2 Appian 14 ## 3 Flavius Josephus 4 ## 4 Xenophon 4 ## 5 Arrian 3 ## 6 Diodorus Siculus 3 ## 7 Philostratus the Athenian 2 ## 8 Achilles Tatius 1 ## 9 Cassius Dio 1 ## 10 Chariton 1 ## 11 Diogenes Laertius 1 ## 12 Dionysius of Halicarnassus 1 ## 13 Eusebius of Caesarea 1 ## 14 Herodotus 1 ## 15 Longus 1 ## 16 Lucian 1 ## 17 Polybius 1 ## 18 Pseudo Apollodorus 1 ## 19 Thucydides 1 ## 20 Xenophon of Ephesus 1 В базовом R мы бы делали то же самое вот так: diorisis_df &lt;- as.data.frame(diorisis_meta) diorisis_select &lt;- diorisis_df[,-5] # remove column diorisis_filter &lt;- diorisis_select[diorisis_select$genre == &quot;Narrative&quot;, ] diorisis_names &lt;- diorisis_filter$name diorisis_count &lt;- as.data.frame(table(diorisis_names)) diorisis_sort &lt;- diorisis_count[order(diorisis_count$Freq, decreasing =T),] head(diorisis_sort) ## diorisis_names Freq ## 15 Plutarch 71 ## 2 Appian 14 ## 10 Flavius Josephus 4 ## 19 Xenophon 4 ## 3 Arrian 3 ## 6 Diodorus Siculus 3 Тут должен быть какой-то поучительный вывод. 4.2 Опрятные данные Но tidyverse – это не только особый синтаксис, но и отдельная идеология “опрятных данных”. “Сырые” данные, с которыми мы работаем, редко бывают опрятны, и перед анализом их следует “почистить” и преобразовать9. Основные правила опрятных данных: отдельный столбец для каждой переменной; отдельный ряд для каждого наблюдения; у каждого значения отдельная ячейка; один датасет – одна таблица. Принципы опрятных данных Посмотрите на учебные тибблы из пакета tidyr и подумайте, какое из этих правил нарушено в каждом случае. data(&quot;table2&quot;) table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 data(&quot;table3&quot;) table3 ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 data(&quot;table4a&quot;) table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 data(&quot;table4b&quot;) table4b ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 Важные функции для преобразования данных из пакета tidyr:10 separate() делит один столбец на новые; unite() объединяет столбцы; pivot_longer() удлиняет таблицу; pivot_wider() расширяет таблицу; drop_na() и replace_na() указывают, что делать с NA и др. Также упомянем функцию distinct() из dplyr, которая оставляет только уникальные наблюдения и предсталяет собой аналог базовой unique() для таблиц. Кроме того, в dplyr есть полезное семейство функций _join, позволяющих объединять данные в различных таблицах.11 Дальше мы потренируемся с ними работать. 4.3 Пример: буккроссинг 4.3.1 Смотрим на данные Загрузим пример неопрятных данных и попробуем их преобразовать для анализа. Book-Crossing – датасет с рейтингами миллионов книг и обезличенными демографическими данными о более 250 тысячах их читателей. Этот датасет хранится в трех разных таблицах. head(ratings) ## # A tibble: 6 × 3 ## `User-ID` ISBN `Book-Rating` ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 276725 034545104X 0 ## 2 276726 0155061224 5 ## 3 276727 0446520802 0 ## 4 276729 052165615X 3 ## 5 276729 0521795028 6 ## 6 276733 2080674722 0 head(users) ## # A tibble: 6 × 3 ## `User-ID` Location Age ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 nyc, new york, usa NULL ## 2 2 stockton, california, usa 18 ## 3 3 moscow, yukon territory, russia NULL ## 4 4 porto, v.n.gaia, portugal 17 ## 5 5 farnborough, hants, united kingdom NULL ## 6 6 santa monica, california, usa 61 head(books) ## # A tibble: 6 × 8 ## ISBN `Book-Title` `Book-Author` `Year-Of-Publication` Publisher `Image-URL-S` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 0195… Classical M… Mark P. O. M… 2002 Oxford U… http://image… ## 2 0002… Clara Callan Richard Bruc… 2001 HarperFl… http://image… ## 3 0060… Decision in… Carlo D&#39;Este 1991 HarperPe… http://image… ## 4 0374… Flu: The St… Gina Bari Ko… 1999 Farrar S… http://image… ## 5 0393… The Mummies… E. J. W. Bar… 1999 W. W. No… http://image… ## 6 0399… The Kitchen… Amy Tan 1991 Putnam P… http://image… ## # ℹ 2 more variables: `Image-URL-M` &lt;chr&gt;, `Image-URL-L` &lt;chr&gt; Что не так с этими данными? users содержит больше одного значения в столбце Location много отсутствующих значений данные вводятся самими пользователями через сайт https://www.bookcrossing.com/ ; они могут содержать недостоверную информацию, см. напр. moscow, yukon territory, russia (Юкон – это территория Канады). Age представляет собой строку и др. Прежде чем начинать преобразование, надо сформулировать примерный вопрос и понять, что для нас важно, а что нет. Например: - Сколько читателей старше 30 лет пользуются сервисом в Австралии? - В какие года опубликованы самые популярные книги? - Кто популярнее у читателей, Роулинг или Толкин? - Какой процент пользователей никогда не оставляет отзывы? - Есть ли связь между возрастом и количеством оценок? и т.п. Чтобы объединить данные, надо понять, через какие переменные они связаны. Ответ: ratings и books связаны через переменную isbn, ratings и users связаны через переменную User-ID. 4.3.2 Трансформируем данные Начнем с пользователей. users_separated &lt;- users %&gt;% mutate(Age = as.numeric(Age)) %&gt;% filter(!is.na(Age)) %&gt;% # drop_na(Age) тоже решил бы нашу задачу separate(Location, into = c(NA, NA, &quot;country&quot;), sep = &quot;,&quot;) head(users_separated) # можно было бы не сохранять, но так нагляднее ## # A tibble: 6 × 3 ## `User-ID` country Age ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 &quot; usa&quot; 18 ## 2 4 &quot; portugal&quot; 17 ## 3 6 &quot; usa&quot; 61 ## 4 10 &quot; spain&quot; 26 ## 5 11 &quot; australia&quot; 14 ## 6 13 &quot; spain&quot; 26 Здесь можно сразу посмотреть, из каких стран и какого возраста пользователи. users_separated %&gt;% group_by(country) %&gt;% count() %&gt;% arrange(-n) ## # A tibble: 543 × 2 ## # Groups: country [543] ## country n ## &lt;chr&gt; &lt;int&gt; ## 1 &quot; usa&quot; 67138 ## 2 &quot; united kingdom&quot; 10935 ## 3 &quot; canada&quot; 9877 ## 4 &quot; spain&quot; 9505 ## 5 &quot; germany&quot; 8016 ## 6 &quot; australia&quot; 7824 ## 7 &lt;NA&gt; 5914 ## 8 &quot; italy&quot; 4754 ## 9 &quot; france&quot; 2395 ## 10 &quot; portugal&quot; 2175 ## # ℹ 533 more rows Последние ряды этого тибла выглядят достаточно причудливо: users_separated %&gt;% group_by(country) %&gt;% count() %&gt;% arrange(n) ## # A tibble: 543 × 2 ## # Groups: country [543] ## country n ## &lt;chr&gt; &lt;int&gt; ## 1 &quot; pasig city.&quot; 1 ## 2 &quot; &amp;#20013;&amp;#22269;&quot; 1 ## 3 &quot; &amp;#32654;&amp;#22269;&quot; 1 ## 4 &quot; 5057chadwick ct.&quot; 1 ## 5 &quot; 600 083&quot; 1 ## 6 &quot; \\\\n/a\\\\\\&quot;&quot; 1 ## 7 &quot; a new year is ahead&quot; 1 ## 8 &quot; aberdeenshire&quot; 1 ## 9 &quot; agusan del sur&quot; 1 ## 10 &quot; alabama&quot; 1 ## # ℹ 533 more rows Здесь возможно несколько стратегий. Можно выбрать все ряды с названиями реальных стран либо (если это соответствует исследовательской задаче) какую-то одну страну. Можно и проигнорировать, если происхождение пользователей не так важно. Допустим, мы решаем сосредоточиться на Испании. Обратите внимание, что в название страны после разделения функцией separate() попали пробелы, и от них надо избавиться. Это делается при помощи регулярных выражений (о них в другой раз) и функции mutate(). spain_data &lt;- users_separated %&gt;% mutate(country = str_replace_all(country, pattern = &quot;\\\\s+&quot;, &quot;&quot;)) %&gt;% # это означает, что пробел мы меняем на &quot;ничто&quot;, т.е. убираем filter(country == &quot;spain&quot;) %&gt;% group_by(Age) %&gt;% count() %&gt;% arrange(-n) head(spain_data) ## # A tibble: 6 × 2 ## # Groups: Age [6] ## Age n ## &lt;dbl&gt; &lt;int&gt; ## 1 25 514 ## 2 26 510 ## 3 23 480 ## 4 24 467 ## 5 28 459 ## 6 27 450 Столбиковая диаграмма подходит для визуализации подобных данных: spain_data %&gt;% ggplot(aes(Age, n)) + geom_bar(stat = &quot;identity&quot;, col = &quot;blue&quot;, fill = &quot;white&quot;) + theme_bw() Какие целеустремленные испанцы! Читают от 0 до 183 лет 😵 После того, как мы убрали лишние пробелы из названий стран, можно фильтровать: spain_id &lt;- users_separated %&gt;% mutate(country = str_replace_all(country, pattern = &quot;\\\\s+&quot;, &quot;&quot;)) %&gt;% filter(country == &quot;spain&quot;) # на этот раз мы не считаем число наблюдений в группе, а забираем все ряды, которые отвечают условию 4.3.3 Объединяем данные Мы уже выяснили, что ratings и users связаны через переменную User-ID, и в ratings хотели бы оставить только те id, которые отвечают заданному условию (страна, возраст и т.п.). Для такого рода объединений как раз подходят функции _join12. Функции семейства _join spain_ratings &lt;- spain_id %&gt;% left_join(ratings) %&gt;% filter(!is.na(ISBN)) %&gt;% filter(`Book-Rating` &gt; 7) %&gt;% # имена синтаксически неправильные, поэтому требуется знак &quot;`&quot; group_by(ISBN) %&gt;% count() %&gt;% arrange(-n) ## Joining with `by = ## join_by(`User-ID`)` spain_ratings ## # A tibble: 1,281 × 2 ## # Groups: ISBN [1,281] ## ISBN n ## &lt;chr&gt; &lt;int&gt; ## 1 8432206407 4 ## 2 8433969978 4 ## 3 846630679X 4 ## 4 8472236552 4 ## 5 8495501198 4 ## 6 840149186X 3 ## 7 8401499585 3 ## 8 8423310353 3 ## 9 8423662152 3 ## 10 8432215007 3 ## # ℹ 1,271 more rows Осталось выяснить, что это за книги. Для этого объединяем spain_ratings и books. spain_books &lt;- spain_ratings %&gt;% filter(n &gt; 2) %&gt;% left_join(books) %&gt;% filter(!is.na(`Book-Title`), !is.na(`Book-Author`)) %&gt;% ungroup() spain_books ## # A tibble: 15 × 9 ## ISBN n `Book-Title` `Book-Author` `Year-Of-Publication` Publisher ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 8432206407 4 Sin Noticias … Eduardo Mend… 1995 Planeta … ## 2 8433969978 4 El Libro de L… Paul Auster 2003 Anagrama ## 3 846630679X 4 La caverna = … Jose Saramago 2002 Punto de… ## 4 8472236552 4 UN Viejo Que … Luis Sepulve… 1993 Tusquets… ## 5 8495501198 4 Memorias de u… Arthur Golden 2001 Suma de … ## 6 840149186X 3 El Club de Lo… N. H. Kleinb… 1995 Plaza &amp;a… ## 7 8401499585 3 Los Pilares d… Ken Follett 1995 Plaza &amp;a… ## 8 8423310353 3 El Camino (Co… Miguel Delib… 1991 Continen… ## 9 8432215007 3 El perfume Patrick Susk… 1997 Editoria… ## 10 8445071408 3 El Senor De L… J. R. R. Tol… 2001 Minotauro ## 11 8445071416 3 El Hobbit J. R. R. Tol… 1991 Minotauro ## 12 8477204055 3 El caballero … Robert Fisher 2000 Obelisco ## 13 8478884459 3 Harry Potter … J. K. Rowling 1999 Lectorum… ## 14 8484602508 3 Diario de Un … Antonio Salas 2003 Temas de… ## 15 8495501112 3 Son De Mar Manuel Vicent 2002 Suma de … ## # ℹ 3 more variables: `Image-URL-S` &lt;chr&gt;, `Image-URL-M` &lt;chr&gt;, ## # `Image-URL-L` &lt;chr&gt; Как минимум мы выяснили, что испанцы предпочитают читать по-испански! (Здесь снова можно подумать. Возможно, у одной книги разные ISBN, и стоило группировать не по ISBN, а по названию или автору?) Осталось избавиться от неинформативных столбцов (это ссылки, часто битые, на изображения обложки). Если мы знаем номера этих столбцов, то это можно сделать по индексу: spain_books %&gt;% select(3:5) %&gt;% rename(title = `Book-Title`, author = `Book-Author`) ## # A tibble: 15 × 3 ## title author `Year-Of-Publication` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Sin Noticias De Gurb (Biblioteca breve) Eduar… 1995 ## 2 El Libro de Las Ilusiones Paul … 2003 ## 3 La caverna = A caverna Jose … 2002 ## 4 UN Viejo Que Leia Novelas De Amor/the Old Men W… Luis … 1993 ## 5 Memorias de una geisha Arthu… 2001 ## 6 El Club de Los Poetas Muertos N. H.… 1995 ## 7 Los Pilares de La Tierra Ken F… 1995 ## 8 El Camino (Coleccion Destinolibro) Migue… 1991 ## 9 El perfume Patri… 1997 ## 10 El Senor De Los Anillos: LA Comunidad Del Anill… J. R.… 2001 ## 11 El Hobbit J. R.… 1991 ## 12 El caballero de la armadura oxidada Rober… 2000 ## 13 Harry Potter y la piedra filosofal J. K.… 1999 ## 14 Diario de Un Skin: Un Topo En El Movimiento Neo… Anton… 2003 ## 15 Son De Mar Manue… 2002 Однако у select() есть функции-помощники13, которые подходят для таких случаев: starts_with() ends_with() contains() matches() num_range() spain_books %&gt;% select(-contains(&quot;URL&quot;), -matches(&quot;Publisher&quot;)) %&gt;% # удалим заодно и издателя rename(title = `Book-Title`, author = `Book-Author`, published = `Year-Of-Publication`) # чиним имена ## # A tibble: 15 × 5 ## ISBN n title author published ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 8432206407 4 Sin Noticias De Gurb (Biblioteca breve) Eduar… 1995 ## 2 8433969978 4 El Libro de Las Ilusiones Paul … 2003 ## 3 846630679X 4 La caverna = A caverna Jose … 2002 ## 4 8472236552 4 UN Viejo Que Leia Novelas De Amor/the Old … Luis … 1993 ## 5 8495501198 4 Memorias de una geisha Arthu… 2001 ## 6 840149186X 3 El Club de Los Poetas Muertos N. H.… 1995 ## 7 8401499585 3 Los Pilares de La Tierra Ken F… 1995 ## 8 8423310353 3 El Camino (Coleccion Destinolibro) Migue… 1991 ## 9 8432215007 3 El perfume Patri… 1997 ## 10 8445071408 3 El Senor De Los Anillos: LA Comunidad Del … J. R.… 2001 ## 11 8445071416 3 El Hobbit J. R.… 1991 ## 12 8477204055 3 El caballero de la armadura oxidada Rober… 2000 ## 13 8478884459 3 Harry Potter y la piedra filosofal J. K.… 1999 ## 14 8484602508 3 Diario de Un Skin: Un Topo En El Movimient… Anton… 2003 ## 15 8495501112 3 Son De Mar Manue… 2002 Возможно, сюда стоит добавить что-то про работу с факторами. Но не сейчас. References "],["функциональное-программирование.html", "Тема 5 Функциональное программирование 5.1 Зачем писать функции? 5.2 Область видимости переменных 5.3 Аргументы функции 5.4 Векторизируй это 5.5 Векторизованные конструкции 5.6 Вместо циклов: базовый R и tidyverse 5.7 Purrr 5.8 Пример итерации 5.9 Furrr", " Тема 5 Функциональное программирование 5.1 Зачем писать функции? Программировать на R – прежде всего значит писать функции. Несмотря на десятки тысяч функций, обитающих в тысячах пакетов, рано или поздно вам понадобится своя функция, которая будет подходить для решения именно ваших задач. Функция и код – не одно и то же. Чтобы стать функцией, кусок кода должен, как минимум, получить имя. Зачем давать имя коду, который и так работает? Вот три причины, которые приводит Хадли Уикхем: у функции есть выразительное имя, которое облегчает понимание кода; при изменении требований необходимо обновлять код только в одном месте, а не во многих; меньше вероятность случайных ошибок при копировании (например, обновление имени переменной в одном месте, но не в другом) Writing good functions is a lifetime journey. — Hadley Wickham Чтобы определить функцию, необходимо дать ей имя. Машине все равно, как вы назовете функцию, но тем, кто будет читать код, не все равно. Имена должны быть информативы (поэтому функция f() – плохая идея). Также не стоит переписывать уже существующие в R имена! Далее следует определить формальные аргументы и, при желании, значения по умолчанию. Тело функции пишется в фигурных скобках. В конце кода функции располагается команда return(); если ее нет, то функция возвращает последнее вычисленное значение (см. здесь о том, когда что предпочесть). Написание функций – навык, который можно бесконечно совершенствовать. Начать проще всего с обычного кода. Убедившись, что он работает как надо, вы можете упаковать его в функцию. Например, нам нужна функция, которая ищет совпадения в двух векторах и возвращает совпавшие элементы. Сначала решим задачу для двух векторов. x &lt;- c(&quot;гнев&quot;, &quot;богиня&quot;, &quot;воспой&quot;) y &lt;- c(&quot;в&quot;, &quot;мысли&quot;, &quot;ему&quot;, &quot;то&quot;, &quot;вложила&quot;, &quot;богиня&quot;, &quot;державная&quot;, &quot;гера&quot;) idx &lt;- which(x %in% y) # 2 x[idx] ## [1] &quot;богиня&quot; Теперь заменяем фактические переменные на формальные. common_words &lt;- function(x, y){ idx &lt;- which(x %in% y) x[idx] } И применяем к новым данным. x &lt;- c(&quot;лишь&quot;, &quot;явилась&quot;, &quot;заря&quot;, &quot;розоперстая&quot;, &quot;вестница&quot;, &quot;утра&quot;) y &lt;- c(&quot;вестница&quot;, &quot;утра&quot;, &quot;заря&quot;, &quot;на&quot;, &quot;великий&quot;, &quot;олимп&quot;, &quot;восходила&quot;) common_words(x, y) ## [1] &quot;заря&quot; &quot;вестница&quot; &quot;утра&quot; Ура, все работает! Запомните простое правило: если вы трижды скопировали код, пора писать функцию! 5.2 Область видимости переменных Напишем функцию, которая будет центрировать данные, то есть вычитать среднее из каждого значения (забудем на время, что это уже делает базовая scale()): center &lt;- function(x){ n = x - mean(x) return(n) } x &lt;- c(5, 10, 15) center(x) ## [1] -5 0 5 Внутри нашей функции есть переменная n, которую не видно в глобальном окружении. Это локальная переменная. Область ее видимости – тело функции. Когда функция возвращает управление, переменная исчезает. Обратное неверно: глобальные переменные доступны в теле функции. 5.3 Аргументы функции Функция может принимать произвольное число аргументов. Доработаем наш код: center &lt;- function(x, na.rm = F){ if(na.rm) { x &lt;- x[!is.na(x)]} # добавим условие x - mean(x) # на этот раз без return() } x &lt;- c(5, 10, NA) center(x) ## [1] NA NA NA Что произошло? Почему следующий код выдает другой результат? center(x, na.rm = T) ## [1] -2.5 2.5 Вычисления в R ленивы, то есть они откладываются до тех пор, пока не понадобится результат. Если вы зададите аргумент, который не нужен в теле функции, ошибки не будет. center &lt;- function(x, na.rm = F, what_is_your_name){ if(na.rm) { x &lt;- x[!is.na(x)]} # добавим условие x - mean(x) # на этот раз без return() } center(x, na.rm = T) ## [1] -2.5 2.5 center(x, na.rm = T, what_is_your_name = &quot;Locusclassicus&quot;) ## [1] -2.5 2.5 Часто имеет смысл добавить условие остановки или сообщение, которое будет распечатано в консоль при выполнении. center &lt;- function(x){ if (length(x) == 1) {stop(&quot;И без меня посчитает&quot;)} x - mean(x) # на этот раз без return() } x &lt;- 10 center(x) # вернет ошибку 5.4 Векторизируй это Теперь самое главное: если мы хотим применить функцию к каждому элементу вектора, то в большинстве случаев достаточно просто вызвать функцию. Это называется векторизация. Это относится не только ко многим встроенным функциям R, но и к даже к операторам. x + 4 в действительности представляет собой +(x, 4): x &lt;- c(1.2, 2.51, 3.8) `+`(x, 4) ## [1] 5.20 6.51 7.80 Ключевую роль здесь играет переработка данных, о которой мы уже говорили: короткий вектор повторяется до тех пор, пока его длина не сравняется с длиной более длинного вектора. Как-то так: \\[\\left( \\begin{array}{c} 1.2 \\\\ 2.51 \\\\ 3.8 \\end{array} \\right) + \\left( \\begin{array}{c} 4 \\\\ 4 \\\\ 4 \\end{array} \\right)\\] Понимание того, как действуют векторизованные вычисления, очень важно для написания корректного кода. Посмотрите на пример ниже: почему функция is_article() возвращает два значения, хотя на входе только одно? is_article &lt;- function(x){ x == c(&quot;a&quot;, &quot;the&quot;) } x &lt;- &quot;the&quot; is_article(x) ## [1] FALSE TRUE Поскольку векторы сравниваются поэлементно, то функция ниже вернет разный результат в зависимости от того, в каком порядке заданы элементы: x &lt;- c(&quot;just&quot;, &quot;the&quot;) is_article(x) ## [1] FALSE TRUE x &lt;- c(&quot;the&quot;, &quot;just&quot;) is_article(x) # взрыв мозга ## [1] FALSE FALSE Подумайте, вектор какого типа и какой длины вернет код ниже. is_article &lt;- function(x) { articles &lt;- c(&quot;a&quot;, &quot;the&quot;) x %in% articles } x &lt;- c(rep(&quot;the&quot;, 5), rep(&quot;if&quot;, 5)) is_article(x) ## [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE 5.5 Векторизованные конструкции 5.5.1 Циклы Еще один способ повторить действия в R, при этом не копируя один и тот же код много раз, – это циклы. Один из главных принципов программирования на R гласит, что следует обходиться без циклов, а если это невозможно, то циклы должны быть простыми. — Нормат Мэтлофф Существует два основных цикла: цикл for и цикл while. На практике чаще используется цикл for, потому что цикл while легко отправить в бесконечность. 5.5.1.1 Цикл for Цикл ниже считает количество букв для каждого слова в векторе. y &lt;- c(&quot;в&quot;, &quot;мысли&quot;, &quot;ему&quot;, &quot;то&quot;, &quot;вложила&quot;, &quot;богиня&quot;, &quot;державная&quot;, &quot;гера&quot;) result &lt;- c() for(i in y) { n &lt;- nchar(i) result &lt;- c(result, n) } result ## [1] 1 5 3 2 7 6 9 4 В данном случае мы указали, что надо совершить какую-то операцию над каждым элементом вектора; но по сути это избыточно, потому что nchar() тоже векторизована. nchar(y) ## [1] 1 5 3 2 7 6 9 4 Поэтому чаще цикл for применяют к другим структурам данных. Например, к спискам и датафреймам. Загрузим и немного изменим датасет о гапаксах у Платона. Изменения нужны, так как цикл работает для данных только одного типа, в то время как в нашей таблице столбец dialogue содержит символьные строки, а group – фактор. Обратите внимание, что оператор pipe и функции из dplyr работают и с обычными датафреймами: rownames(hapax_plato) &lt;- hapax_plato$dialogue hapax_plato &lt;- hapax_plato %&gt;% select(-group, -dialogue) # str(hapax_plato) ## &#39;data.frame&#39;: 26 obs. of 3 variables: ## $ words: chr &quot;8745&quot; &quot;8311&quot; &quot;17944&quot; &quot;4950&quot; ... ## $ hapax: chr &quot;36&quot; &quot;31&quot; &quot;122&quot; &quot;104&quot; ... ## $ ratio: chr &quot;0.004&quot; &quot;0.004&quot; &quot;0.007&quot; &quot;0.021&quot; ... Сейчас все данные в нашей таблице имеют тип chr, то есть строка, и при помощи цикла мы можем их трансформировать. for (i in seq_along(hapax_plato)) { # seq_along ≈ 1:length(x) hapax_plato[,i] &lt;- as.numeric(hapax_plato[,i]) } str(hapax_plato) # убеждаемся, что все получилось ## &#39;data.frame&#39;: 26 obs. of 3 variables: ## $ words: num 8745 8311 17944 4950 4169 ... ## $ hapax: num 36 31 122 104 19 87 15 125 12 32 ... ## $ ratio: num 0.004 0.004 0.007 0.021 0.005 0.007 0.003 0.005 0.003 0.008 ... При помощи циклов можно не только трансформировать данные, но и создавать новые. Чтобы посчитать среднее для столбца, цикл писать не надо: для этого есть функция colSums() (или, для других задач, rowSums()). А вот посчитать медиану таким образом не получится, тут может пригодиться цикл. library(tictoc) tic() medians &lt;- c() for (i in seq_along(hapax_plato)) { m &lt;- median(hapax_plato[,i]) medians &lt;- c(medians, m) } toc() ## 0.003 sec elapsed medians ## [1] 15589.500 94.500 0.007 Мы сохранили результат, инициировав пустой вектор, к которому затем привязали данные по каждому столбцу. Это не всегда хорошая идея, поскольку для больших данных может сильно замедлить цикл14. Еще один способ – сразу инициировать вектор нужной длины. Сравнить скорость можно при помощи пакета tictoc. tic() medians &lt;- vector(&quot;double&quot;, ncol(hapax_plato)) for (i in seq_along(hapax_plato)) { medians[i] &lt;- median(hapax_plato[,i]) } toc() ## 0.003 sec elapsed Второй способ чуть быстрее, и для больших данных это может быть существенно (знала бы я это раньше). Вы уже заметили, что в циклах часто используется буква i. Но никакой особой магии в ней нет! 5.5.1.2 Цикл while Как уже говорилось, с циклами while стоит быть осторожнее. Посмотрите, например, на этот цикл, который перебирает слова, пока не найдет слово длиной 6 букв. Что могло пойти не так? tic() k &lt;- 0 n &lt;- 0 while (n != 6) { k &lt;- k + 1 n &lt;- nchar(y[k]) } y[k] ## [1] &quot;богиня&quot; toc() ## 0.003 sec elapsed То же самое можно сделать без цикла, причем быстрее! tic() y[nchar(y) == 6][1] ## [1] &quot;богиня&quot; toc() ## 0 sec elapsed В целом, ничего незаконного в циклах нет, но множество вложенных друг в друга циклов сложно воспринимать; порой они могут замедлить выполнение кода. И в базовом R, и в диалекте tidyverse для этого есть несколько решений, о которых скажем чуть ниже. Сначала рассмотрим еще одну векторизованную конструкцию – условие. 5.5.2 Условия Иногда необходимо ограничить выполнение функции неким условием. Короткие условия можно писать в одну строку без фигурных скобок. if(any(nchar(y) &gt; 6)) print(&quot;многабукв&quot;) ## [1] &quot;многабукв&quot; Более сложные и множественные условия требуют фигурных скобок. Можно сравнить это с условным периодом: протасис (всегда либо TRUE, либо FALSE) в круглых скобках, аподосис в фигурных. if (sum(nchar(y)) &gt; 10) { print(&quot;много букв&quot;) } else if (sum(nchar(y)) &lt; 5) { print(&quot;мало букв&quot;) } else { print(&quot;норм букв&quot;) } ## [1] &quot;много букв&quot; Также в R можно использовать специальную функцию: ifelse((sum(nchar(y)) &gt; 10), &quot;много букв&quot;, &quot;мало букв&quot;) ## [1] &quot;много букв&quot; Прописывая условие, не забывайте, что применение бинарного оператора к вектору возвращает логический вектор: x &lt;- c(1:10) x &gt;= 5 ## [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE Условия с таким логическим вектором используют первый его элемент (а вряд ли это то, что вам нужно): if (x &gt;= 5) print(&quot;все сработало&quot;) ## Warning in if (x &gt;= 5) print(&quot;все сработало&quot;): the condition has length &gt; 1 and ## only the first element will be used Можно скорректировать код так: if (any(x &gt;= 5)) print(&quot;все сработало&quot;) ## [1] &quot;все сработало&quot; По той же причине внутри условия не надо использовать логические операторы | (“или”) или &amp; (“и”), потому что они векторизованы: x &lt; 3 | x &gt; 7 ## [1] TRUE TRUE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE Вместо этого можно применять || (“или”) или &amp;&amp; (“и”), которые остановятся, дойдя до первого истинного значения. x &lt; 3 || x &gt; 7 ## [1] TRUE 5.6 Вместо циклов: базовый R и tidyverse Функция tapply() из базового R принимает на входе вектор, фактор (или список факторов) и функцию. Каждый фактор должен быть той же длины, что и вектор. Код ниже считает средний процент гапаксов по группам диалогов: load(&quot;./datasets/HapaxPlato.Rdata&quot;) # подготавливаем векторы my_fct &lt;- as.factor(hapax_plato$group) my_vct &lt;- as.numeric(hapax_plato$ratio) # применяем к ним функцию mean() tapply(my_vct, my_fct, mean) ## 1 2 3 ## 0.00550000 0.00750000 0.01133333 На диалекте tidyverse эта задача решается так: hapax_plato %&gt;% mutate(ratio = as.numeric(ratio)) %&gt;% group_by(group) %&gt;% summarise(mean = mean(ratio)) ## # A tibble: 3 × 2 ## group mean ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0.0055 ## 2 2 0.0075 ## 3 3 0.0113 Функция apply() вызывает функцию для каждой строки или столбца матрицы или датафрейма. # избавляемся от факторов и строк rownames(hapax_plato) &lt;- hapax_plato$dialogue hapax_plato &lt;- subset(hapax_plato, select = -c(dialogue, group)) # преобразуем столбцы в числовой формат при помощи apply tic() hapax_plato&lt;- apply(hapax_plato, 2, as.numeric) toc() ## 0.001 sec elapsed Сравните со скростью цикла, который мы написали выше: load(&quot;./datasets/HapaxPlato.Rdata&quot;) # избавляемся от факторов и строк rownames(hapax_plato) &lt;- hapax_plato$dialogue hapax_plato &lt;- subset(hapax_plato, select = -c(dialogue, group)) tic() for (i in seq_along(hapax_plato)) { hapax_plato[,i] &lt;- as.numeric(hapax_plato[,i]) } toc() ## 0.002 sec elapsed Функция apply() позволяет применять к данным собственные функции, в том числе анонимные. hapax_centered &lt;- apply(hapax_plato, 2, function(x) x - mean(x)) head(hapax_centered) ## words hapax ratio ## Apology -10619.423 -110.69231 -0.0031538462 ## Charmides -11053.423 -115.69231 -0.0031538462 ## Cratylus -1420.423 -24.69231 -0.0001538462 ## Critias -14414.423 -42.69231 0.0138461538 ## Crito -15195.423 -127.69231 -0.0021538462 ## Euthydemus -6911.423 -59.69231 -0.0001538462 Опять-таки, все это решается (даже проще) в грамматике dplyr: as_tibble(hapax_plato) %&gt;% mutate(words = words - mean(words), hapax = hapax - mean(hapax), ratio = ratio - mean(ratio)) Видно, что по времени мы при этом сильно не выигрываем; к тому же, нам пришлось повторить один код три раза. Значит, надо что-то менять. Например, так15: tic() as_tibble(hapax_plato) %&gt;% mutate_all(function(x) x - mean(x)) toc() Или даже так16: fn &lt;- function(x) x - mean(x) as_tibble(hapax_plato) %&gt;% mutate(across(1:3, fn)) %&gt;% invisible() В любом случае, нам удалось обойтись без цикла, код понятен и хорошо читается. Функции lapply() и sapply() подходят для применения функций к спискам (и к датафреймам, которые по сути представляют собой прямоугольные списки). Чтобы понять, как они работают, сначала создадим список. При анализе текста со списками приходится иметь дело достаточно часто: объекты типа stylo.corpus, которые создает пакет stylo, по сути являются списками. x &lt;- c(&quot;гнев&quot;, &quot;богиня&quot;, &quot;воспой&quot;) y &lt;- c(&quot;в&quot;, &quot;мысли&quot;, &quot;ему&quot;, &quot;то&quot;, &quot;вложила&quot;, &quot;богиня&quot;, &quot;державная&quot;, &quot;гера&quot;) corpus &lt;- list(x = x, y = y) Наш условный корпус – это список из 2 элементов (текстов), а каждый текст хранится как символьный вектор. Допустим, мы хотим взять из каждого диалога выборку размером 5 слов, то есть применить функцию sample() к элементам списка. При помощи lapply() (l = list) это делается так: set.seed(0211) lapply(corpus, sample, 5, replace = T) ## $x ## [1] &quot;воспой&quot; &quot;воспой&quot; &quot;воспой&quot; &quot;богиня&quot; &quot;воспой&quot; ## ## $y ## [1] &quot;державная&quot; &quot;вложила&quot; &quot;то&quot; &quot;мысли&quot; &quot;вложила&quot; Функция sapply() ведет себя так же, но упрощает результат до вектора или матрицы (s = simplify). sapply(corpus, sample, 5, replace = T) ## x y ## [1,] &quot;богиня&quot; &quot;ему&quot; ## [2,] &quot;гнев&quot; &quot;державная&quot; ## [3,] &quot;гнев&quot; &quot;ему&quot; ## [4,] &quot;богиня&quot; &quot;то&quot; ## [5,] &quot;воспой&quot; &quot;мысли&quot; Функция vapply() позволяет задать тип данных на выходе. vapply(corpus, sample, size = 5, replace = T, character(5)) ## x y ## [1,] &quot;воспой&quot; &quot;то&quot; ## [2,] &quot;богиня&quot; &quot;гера&quot; ## [3,] &quot;гнев&quot; &quot;вложила&quot; ## [4,] &quot;гнев&quot; &quot;гера&quot; ## [5,] &quot;гнев&quot; &quot;мысли&quot; Поскольку наш “корпус” – это список, то применить грамматику dplyr не очень удобно, списко легко превращается в таблицу: stack(corpus) # передвинуть и переименовать: `relocate()` и `rename()` ## values ind ## 1 гнев x ## 2 богиня x ## 3 воспой x ## 4 в y ## 5 мысли y ## 6 ему y ## 7 то y ## 8 вложила y ## 9 богиня y ## 10 державная y ## 11 гера y Теперь повторные выборки можно делать так: set.seed(0211) stack(corpus) %&gt;% group_by(ind) %&gt;% sample_n(size = 5, replace = T) ## # A tibble: 10 × 2 ## # Groups: ind [2] ## values ind ## &lt;chr&gt; &lt;fct&gt; ## 1 воспой x ## 2 воспой x ## 3 воспой x ## 4 богиня x ## 5 воспой x ## 6 державная y ## 7 вложила y ## 8 то y ## 9 мысли y ## 10 вложила y 5.7 Purrr По-настоящему мощный инструмент для итераций – это пакет purrr из семейства tidyverse17. Разработчики предупреждают, что потребуется время, чтобы овладеть этим инструментом (Wickham and Grolemund 2017). You should never feel bad about using a loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work. — Hadley Wickham &amp; Garrett Grolemund В семействе функций map_ из этого пакета всего 23 вариации18. Вот основные из них: map() map_lgl() map_int() map_dbl() map_chr() Все они принимают на входе данные и функцию, которую следует к ним применить, и возвращают результат в том виде, который указан после подчеркивания. Просто map() вернет список, а map_df() – таблицу: hapax_plato %&gt;% as_tibble() %&gt;% map_df(center) %&gt;% head() ## # A tibble: 6 × 3 ## words hapax ratio ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -10619. -111. -0.00315 ## 2 -11053. -116. -0.00315 ## 3 -1420. -24.7 -0.000154 ## 4 -14414. -42.7 0.0138 ## 5 -15195. -128. -0.00215 ## 6 -6911. -59.7 -0.000154 Если на выходе требуется числовой вектор, то используем суффикс dbl: round(map_dbl(hapax_plato, mean), 3) # это именованный вектор! ## words hapax ratio ## 19364.423 146.692 0.007 Если необходимо несколько раз вызывать одну и ту же функцию с двумя аргументами, используется функция map2() 19. Аргументы, которые меняются при каждом вызове, пишутся до функции; аргументы, которые остаются неизменны, – после. mean = list(5, 10, -3) sd = list(1, 5, 50) map2(mean, sd, rnorm, n = 5) ## [[1]] ## [1] 5.727572 4.812749 4.528140 6.565481 4.356073 ## ## [[2]] ## [1] 18.6183347 0.5775309 23.3592929 3.2133071 15.5702820 ## ## [[3]] ## [1] -10.13466 51.54818 -23.10523 -12.53555 -66.80735 Как работает map2() Это можно обобщить следующим образом (источник): Можно было бы предположить, что должны быть и map3(), map4() и т.д., но во всех случаеях, когда у функции больше двух аргументов, используется pmap(). 5.8 Пример итерации Функция map2() в анализе текста: функция, которая принимает на входе список таблиц, созданных функцией slide, и назначает каждому окну id.20. Используется для создания скользящего окна при создании эмбеддингов. corpus_tbl &lt;- as_tibble(stack(corpus)) windows &lt;- slider::slide(corpus_tbl, ~.x, .after = 1) out &lt;- map2(.x = windows, .y = 1:length(windows), ~ mutate(.x, window_id = .y)) # out is a list out[2] ## [[1]] ## # A tibble: 2 × 3 ## values ind window_id ## &lt;chr&gt; &lt;fct&gt; &lt;int&gt; ## 1 богиня x 2 ## 2 воспой x 2 Поскольку второй аргумент – это, по сути, индекс, можно было бы использовать функцию imap(): out &lt;- imap(.x = windows, ~ mutate(.x, window_id = .y)) out[2:3] ## [[1]] ## # A tibble: 2 × 3 ## values ind window_id ## &lt;chr&gt; &lt;fct&gt; &lt;int&gt; ## 1 богиня x 2 ## 2 воспой x 2 ## ## [[2]] ## # A tibble: 2 × 3 ## values ind window_id ## &lt;chr&gt; &lt;fct&gt; &lt;int&gt; ## 1 воспой x 3 ## 2 в y 3 5.9 Furrr Про параллельные вычисления, если останутся силы. References "],["blocks.html", "Тема 6 Blocks 6.1 Equations 6.2 Theorems and proofs 6.3 Callout blocks", " Тема 6 Blocks 6.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{6.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (6.1). 6.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 6.1. Theorem 6.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 6.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["sharing-your-book.html", "Тема 7 Sharing your book 7.1 Publishing 7.2 404 pages 7.3 Metadata for sharing", " Тема 7 Sharing your book 7.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 7.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 7.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
