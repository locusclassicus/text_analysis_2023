# Регулярные выражения и токенизация

## Регулярные выражения

Есть старая шутка, ее приписывают программисту Джейми Завински: если у вас есть проблема, и вы собираетесь ее решать при помощи регулярных выражений, то у вас две проблемы. Регулярные выражения -- это формальный язык, который используется для того, чтобы находить, извлекать и заменять части текста. 

Регулярные выражения (regex, regexp) объединяют **буквальные символы** (литералы) и **метасимволы** (символы-джокеры, англ. wildcard characters). 

Для поиска используется строка-образец (англ. pattern, по-русски её часто называют "шаблоном", "маской"), которая задает правило поиска. Строка замены также может содержать в себе специальные символы. 

Отличный путеводитель по миру регулярных выражений можно найти [здесь](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html).

### Regex в базовом R

В базовом R за работу со строками отвечают, среди прочего, такие функции, как `grep()` и `grepl()`. При этом `grepl()` возвращает TRUE, если шаблон найден в соответствующей символьной строке, а `grep()` возвращает вектор индексов символьных строк, содержащих паттерн. 

Обеим функциям необходим аргумент `pattern` и аргумент `x`, где `pattern` - регулярное выражение, по которому производится поиск, а аргумент `x` - вектор символов, по которым следует искать совпадения.

Функция `gsub()` позволяет производить замену и требует также аргумента `replacement`.

### Литералы и классы

Буквальные символы -- это то, что вы ожидаете увидеть (или не увидеть -- для управляющих и пробельных символов); можно сказать, что это символы, которые ничего не "имеют в виду". Их можно объединять в классы при помощи квадратных скобок, например, так: `[abc]`.

```{r}
vec <- c("a", "d", "c")
grepl("[abc]", vec)
grep("[abc]", vec)
```

Для некоторых классов есть специальные обозначения.

|Класс | Эквивалент | Значение|
|----- | ------- | -----|
| [:upper:] |	[A-Z] |	Символы верхнего регистра |
| [:lower:] |	[a-z] |	Символы нижнего регистра |
| [:alpha:] |	[[:upper:][:lower:]] |	Буквы |
| [:digit:] |	[0-9], т. е. \\d  |	Цифры |
| [:alnum:] |	[[:alpha:][:digit:]] |	Буквы и цифры |
| [:word:] 	| [[:alnum:]_], т. е. \w |	Символы, образующие «слово» |
| [:punct:] |	[-!"#$%&'()*+,./:;<=>?@[\\\]_`{\|}~] |	Знаки пунктуации |
| [:blank:] |	[ \\t] |	Пробел и табуляция |
| [:space:] |	[[:blank:]\v\r\n\f], т. е. \\s |	Пробельные символы |
|[:cntrl:] |	 |	Управляющие символы (перевод строки, табуляция и т.п.) |
| [:graph:] |	 |	Печатные символы |
| [:print:] |	 |	Печатные символы с пробелом |

Эти классы тоже можно задавать в качестве паттерна.

```{r}
vec <- c("жираф", "верблюд1", "0зебра")
gsub( "[[:digit:]]",  "", vec)
```
В качестве классов можно рассматривать и следующие обозначения:

| Представление |	Эквивалент | 	Значение |
|-------------- | ---------- | ----------|
| \\d |	[0-9] |	Цифра |
| \\D |	[^\\d] |	Любой символ, кроме цифры |
| \\w |	[A-Za-zА-Яа-я0-9_] |	Символы, образующие «слово» (буквы, цифры и символ подчёркивания) |
| \\W |	[^\\w] |	Символы, не образующие «слово» |
| \\s |	[ \\t\\v\\r\\n\\f] |	Пробельный символ |
| \\S |	[^\\s] |	Непробельный символ |

```{r}
gsub( "\\d",  "", vec) # вторая косая черта "экранирует" первую
```
Внутри квадратных скобор знак `^` означает отрицание:

```{r}
gsub( "[^[:digit:]]",  "", vec) 
```

### Якоря

Якоря позволяют искать последовательности символов в начале или в конце строки. Знак `^` (вне квадратных скобок!) означает начало строки, а знак `$` -- конец. Мнемоническое правило: First you get the power (^) and then you get the money ($).

```{r}
vec <- c("The spring is a lovely time", 
         "Fall is a time of peace")
grepl("time$", vec)
```
### Метасимволы

Все метасимволы представлены в таблице ниже.

| Описание |	Символ |
| ---------| --------| 
|открывающая квадратная скобка |	[ |
|закрывающая квадратная скобка |	] |
|обратная косая черта |	\\ |
|карет |	^ |
|знак доллара |	$ |
|точка |	. |
|вертикальная черта |	\| |
|знак вопроса |	? |
|астериск |	* |
|плюс |	+ |
|открывающая фигурная скобка |	\{ |
|закрывающая фигурная скобка |	\} |
|открывающая круглая скобка |	( |
|закрывающая круглая скобка	| ) |

Квадратные скобки используются для создания классов, карет и знак доллара -- это якоря, но карет внутри квадратных скобор может также быть отрицанием. Точка -- это любой знак. 

```{r}
vec <- c("жираф", "верблюд1", "0зебра")
grep(".б", vec) 
```

### Экранирование

Если необходимо найти буквальную точку, буквальный знак вопроса и т.п., то используется экранирование: перед знаком ставится косая черта. Но так как сама косая черта -- это метасимвол, но нужно две косые черты, первая из которых экранирует вторую.

```{r}
vec <- c("жираф?", "верблюд.", "зебра")
grep("\\?", vec) 
grepl("\\.", vec)
```

### Квантификация

Квантификатор после символа, символьного класса или группы определяет, сколько раз предшествующее выражение может встречаться. Квантификатор может относиться более чем к одному символу в регулярном выражении, только если это символьный класс или группа.

| Представление |	Число повторений |	Эквивалент |	
| --------------| -----------------| ------------| 
| ? 	| Ноль или одно |	{0,1} 	|
| * 	| Ноль или более |	{0,} 	|
| + 	| Одно или более |	{1,} 	|

Пример:

```{r}
vec <- c("color", "colour", "colouur")
grepl("ou?r", vec) # ноль или одно 
grepl("ou+r", vec) # одно или больше
grepl("ou*r", vec) # ноль или больше
```
Точное число повторений (интервал) можно задать в фигурных скобках:

| Представление |	Число повторений 	|
| ------------- | ----------------  |
| {n} |	Ровно n раз 	|
| {m,n} |	От m до n включительно 	|
| {m,} |	Не менее m 	|
| {,n} |	Не более n |

```{r}
vec <- c("color", "colour", "colouur", "colouuuur")
grepl("ou{1}r", vec)
grepl("ou{1,2}r", vec)
grepl("ou{,2}r", vec) # это включает и ноль!
```

Часто используется последовательность `.*` для обозначения любого количества любых символов между двумя частями регулярного выражения. 

### Жадная и ленивая квантификация

В регулярных выражениях квантификаторам соответствует максимально длинная строка из возможных (квантификаторы являются жадными, англ. greedy). Это может оказаться значительной проблемой. Например, часто ожидают, что выражение `<.*>` найдёт в тексте теги HTML. Однако если в тексте есть более одного HTML-тега, то этому выражению соответствует _целиком строка, содержащая множество тегов_.

```{r}
vec <- c("<p><b>Википедия</b> — свободная энциклопедия, в которой <i>каждый</i> может изменить или дополнить любую статью.</p>")
gsub("<.*>", "", vec) # все исчезло!
```

Чтобы этого избежать, надо поставить после квантификатора знак вопроса. Это сделает его ленивым.

| regex |	значение |
| ------ | -------- |
| ?? |	0 или 1, лучше 0 |
| *? | 	0 или больше, как можно меньше |
| +? |  1 или больше, как можно меньше |
| {n,m}? |	от n до m, как можно меньше |

Пример:

```{r}
gsub("<.*?>", "", vec) # все получилось!
```

### Regex в stringr

Пакет `stringr` не является частью `tidyverse`, хотя и разделяет его принципы^[https://r4ds.had.co.nz/strings.html]. Его надо загружать отдельно:

```{r}
library(stringr)
```

Это очень удобный инструмент для работы со строками. Вот так можно узнать длину строки или объединить ее с другими строками:

```{r}
vec <- c("жираф", "верблюд")
str_length(vec)
str_c("красивый_", vec)
```
Элементы вектора можно объединить в одну строку:

```{r}
str_c(vec, collapse = ", ") # теперь у них общие кавычки
```
С помощью `str_sub()` и `str_sub_all()` можно выбрать часть строки^[https://stringr.tidyverse.org/reference/str_sub.html].

```{r}
vec <- c("жираф", "верблюд")
str_sub(vec, 1, 3)
str_sub(vec, 1, -2)
```

Функции ниже меняют начертание с прописного на строчное или наоборот:

```{r}
VEC <- str_to_upper(vec)
VEC

str_to_lower(VEC)
str_to_title(vec)
```
Одна из полезнейших функций в этом пакете -- `str_view()`; она помогает увидеть, что поймало регулярное выражение -- до того, как вы внесете какие-то изменения в строку.

```{r}
str_view(c("abc", "a.c", "bef"), "a\\.c")
```
Например, с помощью этой функции можно убедиться, что вертикальная черта выступает как логический оператор "или": 

```{r}
str_view(c("grey", "gray"), "gr(e|a)y")
```

Аналогом `grepl()` в `stringr` является функция `str_detect()`

```{r}
library(rcorpora)
data("fruit")
head(fruit)

str_detect(head(fruit), "[aeiou]$")

# какая доля слов заканчивается на гласный?
mean(str_detect(fruit, "[aeiou]$"))

# сколько всего слов заканчивается на гласный?
sum(str_detect(fruit, "[aeiou]$"))
```

Отрицание можно задать двумя способами:

```{r}
data("words")

no_vowels1 <- !str_detect(words, "[aeiou]") # слова без гласных

no_vowels2 <- str_detect(words, "^[^aeiou]+$") # слова без гласных

sum(no_vowels1 != no_vowels2)
```
Логический вектор можно использовать для индексирования:

```{r}
words[!str_detect(words, "[aeiou]")]
```
Эту функцию можно применять вместе с функцией filter() из пакета dplyr:

```{r message=FALSE}
library(dplyr)
gods <- corpora(which = "mythology/greek_gods")

df <- tibble(god = as.character(gods$greek_gods), 
             i = seq_along(god)
             )

df %>% 
  filter(str_detect(god, "s$"))
```
Вариацией этой функции является `str_count()`:

```{r}
str_count(as.character(gods$greek_gods), "[Aa]")
```

Эту функцию удобно использовать вместе с `mutate()` из `dplyr`:

```{r}
```

### Группировка

Круглые скобки используются для группировки.

```{r}

```

### Юникод

## Токенизация 

Токенизация — процесс разделения текста на составляющие (их называют «токенами»). Токенами могут быть слова, символьные или словесные **энграмы** (n-grams), то есть сочетания символов или слов, даже предложения или параграфы. Все зависит от того, какие единицы вам нужны для анализа. 

Визуально процесс токенизации можно представить так^[https://smltar.com/tokenization.html#what-is-a-token]:

![](https://smltar.com/diagram-files/tokenization-black-box.png)

### Токенизация в базовом R

### Токенизация в stringr

### Токенизация в tidytext

### Токенизация в tokenize

To be supplied.
